1 The Role of Algorithms in Computing
What are algorithms? Why is the study of algorithms worthwhile? What is the role
of algorithms relative to other technologies used in computers? In this chapter, we
will answer these questions.
1.1 Algorithms
Informally, an algorithm is any well-defined computational procedure that takes
some value, or set of values, as input and produces some value, or set of values, as
output. An algorithm is thus a sequence of computational steps that transform the
input into the output.
We can also view an algorithm as a tool for solving a well-specified computational
problem. The statement of the problem specifies in general terms the desired
input/output relationship. The algorithm describes a specific computational procedure
for achieving that input/output relationship.
For example, we might need to sort a sequence of numbers into nondecreasing
order. This problem arises frequently in practice and provides fertile ground for
introducing many standard design techniques and analysis tools. Here is how we
formally define the sorting problem:
Input: A sequence of n numbers ha1; a2; : : : ;ani.
Output: A permutation (reordering) ha0
1; a0
2; : : : ; a0
ni of the input sequence such
that a0
1  a0
2      a0
n.
For example, given the input sequence h31; 41; 59; 26; 41; 58i, a sorting algorithm
returns as output the sequence h26; 31; 41; 41; 58; 59i. Such an input sequence is
called an instance of the sorting problem. In general, an instance of a problem
consists of the input (satisfying whatever constraints are imposed in the problem
statement) needed to compute a solution to the problem.6 Chapter 1 The Role of Algorithms in Computing
Because many programs use it as an intermediate step, sorting is a fundamental
operation in computer science. As a result, we have a large number of good sorting
algorithms at our disposal. Which algorithm is best for a given application depends
onóamong other factorsóthe number of items to be sorted, the extent to which
the items are already somewhat sorted, possible restrictions on the item values,
the architecture of the computer, and the kind of storage devices to be used: main
memory, disks, or even tapes.
An algorithm is said to be correct if, for every input instance, it halts with the
correct output. We say that a correct algorithm solves the given computational
problem. An incorrect algorithm might not halt at all on some input instances, or it
might halt with an incorrect answer. Contrary to what you might expect, incorrect
algorithms can sometimes be useful, if we can control their error rate. We shall see
an example of an algorithm with a controllable error rate in Chapter 31 when we
study algorithms for finding large prime numbers. Ordinarily, however, we shall
be concerned only with correct algorithms.
An algorithm can be specified in English, as a computer program, or even as
a hardware design. The only requirement is that the specification must provide a
precise description of the computational procedure to be followed.
What kinds of problems are solved by algorithms?
Sorting is by no means the only computational problem for which algorithms have
been developed. (You probably suspected as much when you saw the size of this
book.) Practical applications of algorithms are ubiquitous and include the following
examples:
 The Human Genome Project has made great progress toward the goals of identifying
all the 100,000 genes in human DNA, determining the sequences of the
3 billion chemical base pairs that make up human DNA, storing this information
in databases, and developing tools for data analysis. Each of these steps
requires sophisticated algorithms. Although the solutions to the various problems
involved are beyond the scope of this book, many methods to solve these
biological problems use ideas from several of the chapters in this book, thereby
enabling scientists to accomplish tasks while using resources efficiently. The
savings are in time, both human and machine, and in money, as more information
can be extracted from laboratory techniques.
 The Internet enables people all around the world to quickly access and retrieve
large amounts of information. With the aid of clever algorithms, sites on the
Internet are able to manage and manipulate this large volume of data. Examples
of problems that make essential use of algorithms include finding good routes
on which the data will travel (techniques for solving such problems appear in1.1 Algorithms 7
Chapter 24), and using a search engine to quickly find pages on which particular
information resides (related techniques are in Chapters 11 and 32).
 Electronic commerce enables goods and services to be negotiated and exchanged
electronically, and it depends on the privacy of personal information
such as credit card numbers, passwords, and bank statements. The core
technologies used in electronic commerce include public-key cryptography and
digital signatures (covered in Chapter 31), which are based on numerical algorithms
and number theory.
 Manufacturing and other commercial enterprises often need to allocate scarce
resources in the most beneficial way. An oil company may wish to know where
to place its wells in order to maximize its expected profit. A political candidate
may want to determine where to spend money buying campaign advertising in
order to maximize the chances of winning an election. An airline may wish
to assign crews to flights in the least expensive way possible, making sure that
each flight is covered and that government regulations regarding crew scheduling
are met. An Internet service provider may wish to determine where to place
additional resources in order to serve its customers more effectively. All of
these are examples of problems that can be solved using linear programming,
which we shall study in Chapter 29.
Although some of the details of these examples are beyond the scope of this
book, we do give underlying techniques that apply to these problems and problem
areas. We also show how to solve many specific problems, including the following:
 We are given a road map on which the distance between each pair of adjacent
intersections is marked, and we wish to determine the shortest route from one
intersection to another. The number of possible routes can be huge, even if we
disallow routes that cross over themselves. How do we choose which of all
possible routes is the shortest? Here, we model the road map (which is itself
a model of the actual roads) as a graph (which we will meet in Part VI and
Appendix B), and we wish to find the shortest path from one vertex to another
in the graph. We shall see how to solve this problem efficiently in Chapter 24.
 We are given two ordered sequences of symbols, X D hx1; x2; : : : ; xmi and
Y D hy1; y2; : : : ; yni, and we wish to find a longest common subsequence of
X and Y . A subsequence of X is just X with some (or possibly all or none) of
its elements removed. For example, one subsequence of hA;B;C;D;E;F;Gi
would be hB; C; E; Gi. The length of a longest common subsequence of X
and Y gives one measure of how similar these two sequences are. For example,
if the two sequences are base pairs in DNA strands, then we might consider
them similar if they have a long common subsequence. If X has m symbols
and Y has n symbols, then X and Y have 2m and 2n possible subsequences,8 Chapter 1 The Role of Algorithms in Computing
respectively. Selecting all possible subsequences of X and Y and matching
them up could take a prohibitively long time unless m and n are very small.
We shall see in Chapter 15 how to use a general technique known as dynamic
programming to solve this problem much more efficiently.
 We are given a mechanical design in terms of a library of parts, where each part
may include instances of other parts, and we need to list the parts in order so
that each part appears before any part that uses it. If the design comprises n
parts, then there are nä possible orders, where nä denotes the factorial function.
Because the factorial function grows faster than even an exponential function,
we cannot feasibly generate each possible order and then verify that, within
that order, each part appears before the parts using it (unless we have only a
few parts). This problem is an instance of topological sorting, and we shall see
in Chapter 22 how to solve this problem efficiently.
 We are given n points in the plane, and we wish to find the convex hull of
these points. The convex hull is the smallest convex polygon containing the
points. Intuitively, we can think of each point as being represented by a nail
sticking out from a board. The convex hull would be represented by a tight
rubber band that surrounds all the nails. Each nail around which the rubber
band makes a turn is a vertex of the convex hull. (See Figure 33.6 on page 1029
for an example.) Any of the 2n subsets of the points might be the vertices
of the convex hull. Knowing which points are vertices of the convex hull is
not quite enough, either, since we also need to know the order in which they
appear. There are many choices, therefore, for the vertices of the convex hull.
Chapter 33 gives two good methods for finding the convex hull.
These lists are far from exhaustive (as you again have probably surmised from
this bookís heft), but exhibit two characteristics that are common to many interesting
algorithmic problems:
1. They have many candidate solutions, the overwhelming majority of which do
not solve the problem at hand. Finding one that does, or one that is ìbest,î can
present quite a challenge.
2. They have practical applications. Of the problems in the above list, finding the
shortest path provides the easiest examples. A transportation firm, such as a
trucking or railroad company, has a financial interest in finding shortest paths
through a road or rail network because taking shorter paths results in lower
labor and fuel costs. Or a routing node on the Internet may need to find the
shortest path through the network in order to route a message quickly. Or a
person wishing to drive from New York to Boston may want to find driving
directions from an appropriate Web site, or she may use her GPS while driving.1.1 Algorithms 9
Not every problem solved by algorithms has an easily identified set of candidate
solutions. For example, suppose we are given a set of numerical values representing
samples of a signal, and we want to compute the discrete Fourier transform of
these samples. The discrete Fourier transform converts the time domain to the frequency
domain, producing a set of numerical coefficients, so that we can determine
the strength of various frequencies in the sampled signal. In addition to lying at
the heart of signal processing, discrete Fourier transforms have applications in data
compression and multiplying large polynomials and integers. Chapter 30 gives
an efficient algorithm, the fast Fourier transform (commonly called the FFT), for
this problem, and the chapter also sketches out the design of a hardware circuit to
compute the FFT.
Data structures
This book also contains several data structures. A data structure is a way to store
and organize data in order to facilitate access and modifications. No single data
structure works well for all purposes, and so it is important to know the strengths
and limitations of several of them.
Technique
Although you can use this book as a ìcookbookî for algorithms, you may someday
encounter a problem for which you cannot readily find a published algorithm (many
of the exercises and problems in this book, for example). This book will teach you
techniques of algorithm design and analysis so that you can develop algorithms on
your own, show that they give the correct answer, and understand their efficiency.
Different chapters address different aspects of algorithmic problem solving. Some
chapters address specific problems, such as finding medians and order statistics in
Chapter 9, computing minimum spanning trees in Chapter 23, and determining a
maximum flow in a network in Chapter 26. Other chapters address techniques,
such as divide-and-conquer in Chapter 4, dynamic programming in Chapter 15,
and amortized analysis in Chapter 17.
Hard problems
Most of this book is about efficient algorithms. Our usual measure of efficiency
is speed, i.e., how long an algorithm takes to produce its result. There are some
problems, however, for which no efficient solution is known. Chapter 34 studies
an interesting subset of these problems, which are known as NP-complete.
Why are NP-complete problems interesting? First, although no efficient algorithm
for an NP-complete problem has ever been found, nobody has ever proven10 Chapter 1 The Role of Algorithms in Computing
that an efficient algorithm for one cannot exist. In other words, no one knows
whether or not efficient algorithms exist for NP-complete problems. Second, the
set of NP-complete problems has the remarkable property that if an efficient algorithm
exists for any one of them, then efficient algorithms exist for all of them. This
relationship among the NP-complete problems makes the lack of efficient solutions
all the more tantalizing. Third, several NP-complete problems are similar, but not
identical, to problems for which we do know of efficient algorithms. Computer
scientists are intrigued by how a small change to the problem statement can cause
a big change to the efficiency of the best known algorithm.
You should know about NP-complete problems because some of them arise surprisingly
often in real applications. If you are called upon to produce an efficient
algorithm for an NP-complete problem, you are likely to spend a lot of time in a
fruitless search. If you can show that the problem is NP-complete, you can instead
spend your time developing an efficient algorithm that gives a good, but not the
best possible, solution.
As a concrete example, consider a delivery company with a central depot. Each
day, it loads up each delivery truck at the depot and sends it around to deliver goods
to several addresses. At the end of the day, each truck must end up back at the depot
so that it is ready to be loaded for the next day. To reduce costs, the company wants
to select an order of delivery stops that yields the lowest overall distance traveled
by each truck. This problem is the well-known ìtraveling-salesman problem,î and
it is NP-complete. It has no known efficient algorithm. Under certain assumptions,
however, we know of efficient algorithms that give an overall distance which is
not too far above the smallest possible. Chapter 35 discusses such ìapproximation
algorithms.î
Parallelism
For many years, we could count on processor clock speeds increasing at a steady
rate. Physical limitations present a fundamental roadblock to ever-increasing clock
speeds, however: because power density increases superlinearly with clock speed,
chips run the risk of melting once their clock speeds become high enough. In order
to perform more computations per second, therefore, chips are being designed to
contain not just one but several processing ìcores.î We can liken these multicore
computers to several sequential computers on a single chip; in other words, they are
a type of ìparallel computer.î In order to elicit the best performance from multicore
computers, we need to design algorithms with parallelism in mind. Chapter 27
presents a model for ìmultithreadedî algorithms, which take advantage of multiple
cores. This model has advantages from a theoretical standpoint, and it forms the
basis of several successful computer programs, including a championship chess
program.1.2 Algorithms as a technology 11
Exercises
1.1-1
Give a real-world example that requires sorting or a real-world example that requires
computing a convex hull.
1.1-2
Other than speed, what other measures of efficiency might one use in a real-world
setting?
1.1-3
Select a data structure that you have seen previously, and discuss its strengths and
limitations.
1.1-4
How are the shortest-path and traveling-salesman problems given above similar?
How are they different?
1.1-5
Come up with a real-world problem in which only the best solution will do. Then
come up with one in which a solution that is ìapproximatelyî the best is good
enough.
1.2 Algorithms as a technology
Suppose computers were infinitely fast and computer memory was free. Would
you have any reason to study algorithms? The answer is yes, if for no other reason
than that you would still like to demonstrate that your solution method terminates
and does so with the correct answer.
If computers were infinitely fast, any correct method for solving a problem
would do. You would probably want your implementation to be within the bounds
of good software engineering practice (for example, your implementation should
be well designed and documented), but you would most often use whichever
method was the easiest to implement.
Of course, computers may be fast, but they are not infinitely fast. And memory
may be inexpensive, but it is not free. Computing time is therefore a bounded
resource, and so is space in memory. You should use these resources wisely, and
algorithms that are efficient in terms of time or space will help you do so.12 Chapter 1 The Role of Algorithms in Computing
Efficiency
Different algorithms devised to solve the same problem often differ dramatically in
their efficiency. These differences can be much more significant than differences
due to hardware and software.
As an example, in Chapter 2, we will see two algorithms for sorting. The first,
known as insertion sort, takes time roughly equal to c1n2 to sort n items, where c1
is a constant that does not depend on n. That is, it takes time roughly proportional
to n2. The second, merge sort, takes time roughly equal to c2n lg n, where lg n
stands for log2 n and c2 is another constant that also does not depend on n. Insertion
sort typically has a smaller constant factor than merge sort, so that c1 < c2.
We shall see that the constant factors can have far less of an impact on the running
time than the dependence on the input size n. Letís write insertion sortís running
time as c1n  n and merge sortís running time as c2n  lg n. Then we see that where
insertion sort has a factor of n in its running time, merge sort has a factor of lg n,
which is much smaller. (For example, when n D 1000, lgn is approximately 10,
and when n equals one million, lg n is approximately only 20.) Although insertion
sort usually runs faster than merge sort for small input sizes, once the input size n
becomes large enough, merge sortís advantage of lg n vs. n will more than compensate
for the difference in constant factors. No matter how much smaller c1 is
than c2, there will always be a crossover point beyond which merge sort is faster.
For a concrete example, let us pit a faster computer (computer A) running insertion
sort against a slower computer (computer B) running merge sort. They each
must sort an array of 10 million numbers. (Although 10 million numbers might
seem like a lot, if the numbers are eight-byte integers, then the input occupies
about 80 megabytes, which fits in the memory of even an inexpensive laptop computer
many times over.) Suppose that computer A executes 10 billion instructions
per second (faster than any single sequential computer at the time of this writing)
and computer B executes only 10 million instructions per second, so that computer
A is 1000 times faster than computer B in raw computing power. To make
the difference even more dramatic, suppose that the worldís craftiest programmer
codes insertion sort in machine language for computer A, and the resulting code
requires 2n2 instructions to sort n numbers. Suppose further that just an average
programmer implements merge sort, using a high-level language with an inefficient
compiler, with the resulting code taking 50n lg n instructions. To sort 10 million
numbers, computer A takes
2  .107/2 instructions
1010 instructions/second
D 20,000 seconds (more than 5.5 hours) ;
while computer B takes1.2 Algorithms as a technology 13
50  107 lg 107 instructions
107 instructions/second
 1163 seconds (less than 20 minutes) :
By using an algorithm whose running time grows more slowly, even with a poor
compiler, computer B runs more than 17 times faster than computer A! The advantage
of merge sort is even more pronounced when we sort 100 million numbers:
where insertion sort takes more than 23 days, merge sort takes under four hours.
In general, as the problem size increases, so does the relative advantage of merge
sort.
Algorithms and other technologies
The example above shows that we should consider algorithms, like computer hardware,
as a technology. Total system performance depends on choosing efficient
algorithms as much as on choosing fast hardware. Just as rapid advances are being
made in other computer technologies, they are being made in algorithms as well.
You might wonder whether algorithms are truly that important on contemporary
computers in light of other advanced technologies, such as
 advanced computer architectures and fabrication technologies,
 easy-to-use, intuitive, graphical user interfaces (GUIs),
 object-oriented systems,
 integrated Web technologies, and
 fast networking, both wired and wireless.
The answer is yes. Although some applications do not explicitly require algorithmic
content at the application level (such as some simple,Web-based applications),
many do. For example, consider aWeb-based service that determines how to travel
from one location to another. Its implementation would rely on fast hardware, a
graphical user interface, wide-area networking, and also possibly on object orientation.
However, it would also require algorithms for certain operations, such
as finding routes (probably using a shortest-path algorithm), rendering maps, and
interpolating addresses.
Moreover, even an application that does not require algorithmic content at the
application level relies heavily upon algorithms. Does the application rely on fast
hardware? The hardware design used algorithms. Does the application rely on
graphical user interfaces? The design of any GUI relies on algorithms. Does the
application rely on networking? Routing in networks relies heavily on algorithms.
Was the application written in a language other than machine code? Then it was
processed by a compiler, interpreter, or assembler, all of which make extensive use14 Chapter 1 The Role of Algorithms in Computing
of algorithms. Algorithms are at the core of most technologies used in contemporary
computers.
Furthermore, with the ever-increasing capacities of computers, we use them to
solve larger problems than ever before. As we saw in the above comparison between
insertion sort and merge sort, it is at larger problem sizes that the differences
in efficiency between algorithms become particularly prominent.
Having a solid base of algorithmic knowledge and technique is one characteristic
that separates the truly skilled programmers from the novices. With modern computing
technology, you can accomplish some tasks without knowing much about
algorithms, but with a good background in algorithms, you can do much, much
more.
Exercises
1.2-1
Give an example of an application that requires algorithmic content at the application
level, and discuss the function of the algorithms involved.
1.2-2
Suppose we are comparing implementations of insertion sort and merge sort on the
same machine. For inputs of size n, insertion sort runs in 8n2 steps, while merge
sort runs in 64n lg n steps. For which values of n does insertion sort beat merge
sort?
1.2-3
What is the smallest value of n such that an algorithm whose running time is 100n2
runs faster than an algorithm whose running time is 2n on the same machine?
Problems
1-1 Comparison of running times
For each function f .n/ and time t in the following table, determine the largest
size n of a problem that can be solved in time t , assuming that the algorithm to
solve the problem takes f .n/ microseconds.Notes for Chapter 1 15
1 1 1 1 1 1 1
second minute hour day month year century
lg n
p
n
n
n lg n
n2
n3
2n
nä
Chapter notes
There are many excellent texts on the general topic of algorithms, including those
by Aho, Hopcroft, and Ullman [5, 6]; Baase and Van Gelder [28]; Brassard and
Bratley [54]; Dasgupta, Papadimitriou, and Vazirani [82]; Goodrich and Tamassia
[148]; Hofri [175]; Horowitz, Sahni, and Rajasekaran [181]; Johnsonbaugh and
Schaefer [193]; Kingston [205]; Kleinberg and Tardos [208]; Knuth [209, 210,
211]; Kozen [220]; Levitin [235]; Manber [242]; Mehlhorn [249, 250, 251]; Purdom
and Brown [287]; Reingold, Nievergelt, and Deo [293]; Sedgewick [306];
Sedgewick and Flajolet [307]; Skiena [318]; and Wilf [356]. Some of the more
practical aspects of algorithm design are discussed by Bentley [42, 43] and Gonnet
[145]. Surveys of the field of algorithms can also be found in the Handbook of Theoretical
Computer Science, Volume A [342] and the CRC Algorithms and Theory of
Computation Handbook [25]. Overviews of the algorithms used in computational
biology can be found in textbooks by Gusfield [156], Pevzner [275], Setubal and
Meidanis [310], and Waterman [350].2 Getting Started
This chapter will familiarize you with the framework we shall use throughout the
book to think about the design and analysis of algorithms. It is self-contained, but
it does include several references to material that we introduce in Chapters 3 and 4.
(It also contains several summations, which Appendix A shows how to solve.)
We begin by examining the insertion sort algorithm to solve the sorting problem
introduced in Chapter 1. We define a ìpseudocodeî that should be familiar to you if
you have done computer programming, and we use it to show how we shall specify
our algorithms. Having specified the insertion sort algorithm, we then argue that it
correctly sorts, and we analyze its running time. The analysis introduces a notation
that focuses on how that time increases with the number of items to be sorted.
Following our discussion of insertion sort, we introduce the divide-and-conquer
approach to the design of algorithms and use it to develop an algorithm called
merge sort. We end with an analysis of merge sortís running time.
2.1 Insertion sort
Our first algorithm, insertion sort, solves the sorting problem introduced in Chapter
1:
Input: A sequence of n numbers ha1; a2; : : : ;ani.
Output: A permutation (reordering) ha0
1; a0
2; : : : ; a0
ni of the input sequence such
that a0
1  a0
2      a0
n.
The numbers that we wish to sort are also known as the keys. Although conceptually
we are sorting a sequence, the input comes to us in the form of an array with n
elements.
In this book, we shall typically describe algorithms as programs written in a
pseudocode that is similar in many respects to C, C++, Java, Python, or Pascal. If
you have been introduced to any of these languages, you should have little trouble2.1 Insertion sort 17
2
? ?
? 2
?
4
? ? ?
? 4
?
5
? ? ?
? ? 5
?
?
7
? ?
? ?
? ?
? 7
?
10
? ? ? ?
? ?
?? ?
? ?
10
?
Figure 2.1 Sorting a hand of cards using insertion sort.
reading our algorithms. What separates pseudocode from ìrealî code is that in
pseudocode, we employ whatever expressive method is most clear and concise to
specify a given algorithm. Sometimes, the clearest method is English, so do not
be surprised if you come across an English phrase or sentence embedded within
a section of ìrealî code. Another difference between pseudocode and real code
is that pseudocode is not typically concerned with issues of software engineering.
Issues of data abstraction, modularity, and error handling are often ignored in order
to convey the essence of the algorithm more concisely.
We start with insertion sort, which is an efficient algorithm for sorting a small
number of elements. Insertion sort works the way many people sort a hand of
playing cards. We start with an empty left hand and the cards face down on the
table. We then remove one card at a time from the table and insert it into the
correct position in the left hand. To find the correct position for a card, we compare
it with each of the cards already in the hand, from right to left, as illustrated in
Figure 2.1. At all times, the cards held in the left hand are sorted, and these cards
were originally the top cards of the pile on the table.
We present our pseudocode for insertion sort as a procedure called INSERTIONSORT,
which takes as a parameter an array AOE1 : : n containing a sequence of
length n that is to be sorted. (In the code, the number n of elements in A is denoted
by A:length.) The algorithm sorts the input numbers in place: it rearranges the
numbers within the array A, with at most a constant number of them stored outside
the array at any time. The input array A contains the sorted output sequence when
the INSERTION-SORT procedure is finished.18 Chapter 2 Getting Started
1 2 3 4 5 6
(a) 5 2 4 6 1 3
1 2 3 4 5 6
(b) 2 5 4 6 1 3
1 2 3 4 5 6
(c) 2 4 5 6 1 3
1 2 3 4 5 6
(d) 2 4 5 6 1 3
1 2 3 4 5 6
(e) 1 2 4 5 6 3
1 2 3 4 5 6
(f) 1 2 3 4 5 6
Figure 2.2 The operation of INSERTION-SORT on the array A D h5; 2; 4; 6; 1; 3i. Array indices
appear above the rectangles, and values stored in the array positions appear within the rectangles.
(a)ñ(e) The iterations of the for loop of lines 1ñ8. In each iteration, the black rectangle holds the
key taken from AOEj , which is compared with the values in shaded rectangles to its left in the test of
line 5. Shaded arrows show array values moved one position to the right in line 6, and black arrows
indicate where the key moves to in line 8. (f) The final sorted array.
INSERTION-SORT.A/
1 for j D 2 to A:length
2 key D AOEj 
3 // Insert AOEj  into the sorted sequence AOE1 : : j  1.
4 i D j  1
5 while i > 0 and AOEi > key
6 AOEi C 1 D AOEi
7 i D i  1
8 AOEi C 1 D key
Loop invariants and the correctness of insertion sort
Figure 2.2 shows how this algorithm works for A D h5; 2; 4; 6; 1; 3i. The index
j indicates the ìcurrent cardî being inserted into the hand. At the beginning
of each iteration of the for loop, which is indexed by j , the subarray consisting
of elements AOE1 : : j  1 constitutes the currently sorted hand, and the remaining
subarray AOEj C 1: : n corresponds to the pile of cards still on the table. In fact,
elements AOE1 : : j  1 are the elements originally in positions 1 through j 1, but
now in sorted order. We state these properties of AOE1 : : j  1 formally as a loop
invariant:
At the start of each iteration of the for loop of lines 1ñ8, the subarray
AOE1 : : j 1 consists of the elements originally in AOE1 : : j 1, but in sorted
order.
We use loop invariants to help us understand why an algorithm is correct. We
must show three things about a loop invariant:2.1 Insertion sort 19
Initialization: It is true prior to the first iteration of the loop.
Maintenance: If it is true before an iteration of the loop, it remains true before the
next iteration.
Termination: When the loop terminates, the invariant gives us a useful property
that helps show that the algorithm is correct.
When the first two properties hold, the loop invariant is true prior to every iteration
of the loop. (Of course, we are free to use established facts other than the loop
invariant itself to prove that the loop invariant remains true before each iteration.)
Note the similarity to mathematical induction, where to prove that a property holds,
you prove a base case and an inductive step. Here, showing that the invariant holds
before the first iteration corresponds to the base case, and showing that the invariant
holds from iteration to iteration corresponds to the inductive step.
The third property is perhaps the most important one, since we are using the loop
invariant to show correctness. Typically, we use the loop invariant along with the
condition that caused the loop to terminate. The termination property differs from
how we usually use mathematical induction, in which we apply the inductive step
infinitely; here, we stop the ìinductionî when the loop terminates.
Let us see how these properties hold for insertion sort.
Initialization: We start by showing that the loop invariant holds before the first
loop iteration, when j D 2.1 The subarray AOE1 : : j  1, therefore, consists
of just the single element AOE1, which is in fact the original element in AOE1.
Moreover, this subarray is sorted (trivially, of course), which shows that the
loop invariant holds prior to the first iteration of the loop.
Maintenance: Next, we tackle the second property: showing that each iteration
maintains the loop invariant. Informally, the body of the for loop works by
moving AOEj  1, AOEj  2, AOEj  3, and so on by one position to the right
until it finds the proper position for AOEj  (lines 4ñ7), at which point it inserts
the value of AOEj  (line 8). The subarray AOE1 : : j  then consists of the elements
originally in AOE1 : : j , but in sorted order. Incrementing j for the next iteration
of the for loop then preserves the loop invariant.
A more formal treatment of the second property would require us to state and
show a loop invariant for the while loop of lines 5ñ7. At this point, however,
1When the loop is a for loop, the moment at which we check the loop invariant just prior to the first
iteration is immediately after the initial assignment to the loop-counter variable and just before the
first test in the loop header. In the case of INSERTION-SORT, this time is after assigning 2 to the
variable j but before the first test of whether j  A:length.20 Chapter 2 Getting Started
we prefer not to get bogged down in such formalism, and so we rely on our
informal analysis to show that the second property holds for the outer loop.
Termination: Finally, we examine what happens when the loop terminates. The
condition causing the for loop to terminate is thatj >A:length D n. Because
each loop iteration increases j by 1, we must have j D n C 1 at that time.
Substituting n C 1 for j in the wording of loop invariant, we have that the
subarray AOE1 : : n consists of the elements originally in AOE1 : : n, but in sorted
order. Observing that the subarray AOE1 : : n is the entire array, we conclude that
the entire array is sorted. Hence, the algorithm is correct.
We shall use this method of loop invariants to show correctness later in this
chapter and in other chapters as well.
Pseudocode conventions
We use the following conventions in our pseudocode.
 Indentation indicates block structure. For example, the body of the for loop that
begins on line 1 consists of lines 2ñ8, and the body of the while loop that begins
on line 5 contains lines 6ñ7 but not line 8. Our indentation style applies to
if-else statements2 as well. Using indentation instead of conventional indicators
of block structure, such as begin and end statements, greatly reduces clutter
while preserving, or even enhancing, clarity.3
 The looping constructs while, for, and repeat-until and the if-else conditional
construct have interpretations similar to those in C, C++, Java, Python, and
Pascal.4 In this book, the loop counter retains its value after exiting the loop,
unlike some situations that arise in C++, Java, and Pascal. Thus, immediately
after a for loop, the loop counterís value is the value that first exceeded the for
loop bound. We used this property in our correctness argument for insertion
sort. The for loop header in line 1 is for j D 2 to A:length, and so when
this loop terminates, j D A:length C 1 (or, equivalently, j D n C 1, since
n D A:length). We use the keyword to when a for loop increments its loop
2In an if-else statement, we indent else at the same level as its matching if. Although we omit the
keyword then, we occasionally refer to the portion executed when the test following if is true as a
then clause. For multiway tests, we use elseif for tests after the first one.
3Each pseudocode procedure in this book appears on one page so that you will not have to discern
levels of indentation in code that is split across pages.
4Most block-structured languages have equivalent constructs, though the exact syntax may differ.
Python lacks repeat-until loops, and its for loops operate a little differently from the for loops in
this book.2.1 Insertion sort 21
counter in each iteration, and we use the keyword downto when a for loop
decrements its loop counter. When the loop counter changes by an amount
greater than 1, the amount of change follows the optional keyword by.
 The symbol ì//î indicates that the remainder of the line is a comment.
 A multiple assignment of the form i D j D e assigns to both variables i and j
the value of expression e; it should be treated as equivalent to the assignment
j D e followed by the assignment i D j .
 Variables (such as i , j, and key) are local to the given procedure. We shall not
use global variables without explicit indication.
 We access array elements by specifying the array name followed by the index
in square brackets. For example, AOEi indicates the i th element of the
array A. The notation ì: :î is used to indicate a range of values within an array.
Thus, AOE1 : : j  indicates the subarray of A consisting of the j elements
AOE1;AOE2; : : : ;AOEj.
 We typically organize compound data into objects, which are composed of
attributes. We access a particular attribute using the syntax found in many
object-oriented programming languages: the object name, followed by a dot,
followed by the attribute name. For example, we treat an array as an object
with the attribute length indicating how many elements it contains. To specify
the number of elements in an array A, we write A:length.
We treat a variable representing an array or object as a pointer to the data representing
the array or object. For all attributes f of an object x, setting y D x
causes y:f to equal x:f . Moreover, if we now set x:f D 3, then afterward not
only does x:f equal 3, but y:f equals 3 as well. In other words, x and y point
to the same object after the assignment y D x.
Our attribute notation can ìcascade.î For example, suppose that the attribute f
is itself a pointer to some type of object that has an attribute g. Then the notation
x:f :g is implicitly parenthesized as .x: f /:g. In other words, if we had assigned
y D x:f , then x:f :g is the same as y:g.
Sometimes, a pointer will refer to no object at all. In this case, we give it the
special value NIL.
 We pass parameters to a procedure by value: the called procedure receives its
own copy of the parameters, and if it assigns a value to a parameter, the change
is not seen by the calling procedure. When objects are passed, the pointer to
the data representing the object is copied, but the objectís attributes are not. For
example, if x is a parameter of a called procedure, the assignment x D y within
the called procedure is not visible to the calling procedure. The assignment
x:f D 3, however, is visible. Similarly, arrays are passed by pointer, so that22 Chapter 2 Getting Started
a pointer to the array is passed, rather than the entire array, and changes to
individual array elements are visible to the calling procedure.
 A return statement immediately transfers control back to the point of call in
the calling procedure. Most return statements also take a value to pass back to
the caller. Our pseudocode differs from many programming languages in that
we allow multiple values to be returned in a single return statement.
 The boolean operators ìandî and ìorî are short circuiting. That is, when we
evaluate the expression ìx and yî we first evaluate x. If x evaluates to FALSE,
then the entire expression cannot evaluate to TRUE, and so we do not evaluate y.
If, on the other hand, x evaluates to TRUE, wemust evaluate y to determine the
value of the entire expression. Similarly, in the expression ìx or yî we evaluate
the expression y only if x evaluates to FALSE. Short-circuiting operators
allow us to write boolean expressions such as ìx § NIL and x:f D yî without
worrying about what happens when we try to evaluate x:f when x is NIL.
 The keyword error indicates that an error occurred because conditions were
wrong for the procedure to have been called. The calling procedure is responsible
for handling the error, and so we do not specify what action to take.
Exercises
2.1-1
Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the
array A D h31; 41; 59; 26; 41; 58i.
2.1-2
Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of nondecreasing
order.
2.1-3
Consider the searching problem:
Input: A sequence of n numbers A D ha1; a2; : : : ;ani and a value .
Output: An index i such that  D AOEi or the special value NIL if  does not
appear in A.
Write pseudocode for linear search, which scans through the sequence, looking
for . Using a loop invariant, prove that your algorithm is correct. Make sure that
your loop invariant fulfills the three necessary properties.
2.1-4
Consider the problem of adding two n-bit binary integers, stored in two n-element
arrays A and B. The sum of the two integers should be stored in binary form in2.2 Analyzing algorithms 23
an .n C 1/-element array C. State the problem formally and write pseudocode for
adding the two integers.
2.2 Analyzing algorithms
Analyzing an algorithm has come to mean predicting the resources that the algorithm
requires. Occasionally, resources such as memory, communication bandwidth,
or computer hardware are of primary concern, but most often it is computational
time that we want to measure. Generally, by analyzing several candidate
algorithms for a problem, we can identify a most efficient one. Such analysis may
indicate more than one viable candidate, but we can often discard several inferior
algorithms in the process.
Before we can analyze an algorithm, we must have a model of the implementation
technology that we will use, including a model for the resources of that
technology and their costs. For most of this book, we shall assume a generic oneprocessor,
random-access machine (RAM) model of computation as our implementation
technology and understand that our algorithms will be implemented as
computer programs. In the RAM model, instructions are executed one after another,
with no concurrent operations.
Strictly speaking, we should precisely define the instructions of the RAM model
and their costs. To do so, however, would be tedious and would yield little insight
into algorithm design and analysis. Yet we must be careful not to abuse the RAM
model. For example, what if a RAM had an instruction that sorts? Then we could
sort in just one instruction. Such a RAMwould be unrealistic, since real computers
do not have such instructions. Our guide, therefore, is how real computers are designed.
The RAM model contains instructions commonly found in real computers:
arithmetic (such as add, subtract, multiply, divide, remainder, floor, ceiling), data
movement (load, store, copy), and control (conditional and unconditional branch,
subroutine call and return). Each such instruction takes a constant amount of time.
The data types in the RAM model are integer and floating point (for storing real
numbers). Although we typically do not concern ourselves with precision in this
book, in some applications precision is crucial. We also assume a limit on the size
of each word of data. For example, when working with inputs of size n, we typically
assume that integers are represented by c lg n bits for some constant c  1.
We require c  1 so that each word can hold the value of n, enabling us to index the
individual input elements, and we restrict c to be a constant so that the word size
does not grow arbitrarily. (If the word size could grow arbitrarily, we could store
huge amounts of data in one word and operate on it all in constant timeóclearly
an unrealistic scenario.)24 Chapter 2 Getting Started
Real computers contain instructions not listed above, and such instructions represent
a gray area in the RAM model. For example, is exponentiation a constanttime
instruction? In the general case, no; it takes several instructions to compute xy
when x and y are real numbers. In restricted situations, however, exponentiation is
a constant-time operation. Many computers have a ìshift leftî instruction, which
in constant time shifts the bits of an integer by k positions to the left. In most
computers, shifting the bits of an integer by one position to the left is equivalent
to multiplication by 2, so that shifting the bits by k positions to the left is equivalent
to multiplication by 2k. Therefore, such computers can compute 2k in one
constant-time instruction by shifting the integer 1 by k positions to the left, as long
as k is no more than the number of bits in a computer word. We will endeavor to
avoid such gray areas in the RAM model, but we will treat computation of 2k as a
constant-time operation when k is a small enough positive integer.
In the RAM model, we do not attempt to model the memory hierarchy that is
common in contemporary computers. That is, we do not model caches or virtual
memory. Several computational models attempt to account for memory-hierarchy
effects, which are sometimes significant in real programs on real machines. A
handful of problems in this book examine memory-hierarchy effects, but for the
most part, the analyses in this book will not consider them. Models that include
the memory hierarchy are quite a bit more complex than the RAM model, and so
they can be difficult to work with. Moreover, RAM-model analyses are usually
excellent predictors of performance on actual machines.
Analyzing even a simple algorithm in the RAM model can be a challenge. The
mathematical tools required may include combinatorics, probability theory, algebraic
dexterity, and the ability to identify the most significant terms in a formula.
Because the behavior of an algorithm may be different for each possible input, we
need a means for summarizing that behavior in simple, easily understood formulas.
Even though we typically select only one machine model to analyze a given algorithm,
we still face many choices in deciding how to express our analysis. We
would like a way that is simple to write and manipulate, shows the important characteristics
of an algorithmís resource requirements, and suppresses tedious details.
Analysis of insertion sort
The time taken by the INSERTION-SORT procedure depends on the input: sorting a
thousand numbers takes longer than sorting three numbers. Moreover, INSERTIONSORT
can take different amounts of time to sort two input sequences of the same
size depending on how nearly sorted they already are. In general, the time taken
by an algorithm grows with the size of the input, so it is traditional to describe the
running time of a program as a function of the size of its input. To do so, we need
to define the terms ìrunning timeî and ìsize of inputî more carefully.2.2 Analyzing algorithms 25
The best notion for input size depends on the problem being studied. For many
problems, such as sorting or computing discrete Fourier transforms, the most natural
measure is the number of items in the inputófor example, the array size n
for sorting. For many other problems, such as multiplying two integers, the best
measure of input size is the total number of bits needed to represent the input in
ordinary binary notation. Sometimes, it is more appropriate to describe the size of
the input with two numbers rather than one. For instance, if the input to an algorithm
is a graph, the input size can be described by the numbers of vertices and
edges in the graph. We shall indicate which input size measure is being used with
each problem we study.
The running time of an algorithm on a particular input is the number of primitive
operations or ìstepsî executed. It is convenient to define the notion of step so
that it is as machine-independent as possible. For the moment, let us adopt the
following view. A constant amount of time is required to execute each line of our
pseudocode. One line may take a different amount of time than another line, but
we shall assume that each execution of the i th line takes time ci, where ci is a
constant. This viewpoint is in keeping with the RAM model, and it also reflects
how the pseudocode would be implemented on most actual computers.5
In the following discussion, our expression for the running time of INSERTIONSORT
will evolve from a messy formula that uses all the statement costs ci to a
much simpler notation that is more concise and more easily manipulated. This
simpler notation will also make it easy to determine whether one algorithm is more
efficient than another.
We start by presenting the INSERTION-SORT procedure with the time ìcostî
of each statement and the number of times each statement is executed. For each
j D 2;3; : : : ;n, where n D A:length, we let tj denote the number of times the
while loop test in line 5 is executed for that value of j. When a for or while loop
exits in the usual way (i.e., due to the test in the loop header), the test is executed
one time more than the loop body. We assume that comments are not executable
statements, and so they take no time.
5There are some subtleties here. Computational steps that we specify in English are often variants
of a procedure that requires more than just a constant amount of time. For example, later in this
book we might say ìsort the points by x-coordinate,î which, as we shall see, takes more than a
constant amount of time. Also, note that a statement that calls a subroutine takes constant time,
though the subroutine, once invoked, may take more. That is, we separate the process of calling the
subroutineópassing parameters to it, etc.ófrom the process of executing the subroutine.26 Chapter 2 Getting Started
INSERTION-SORT.A/ cost times
1 for j D 2 to A:length c1 n
2 key D AOEj  c2 n  1
3 // Insert AOEj  into the sorted
sequence AOE1 : : j  1. 0 n  1
4 i D j 1 c4 n  1
5 while i > 0 and AOEi > key c5
Pn
jD2 tj
6 AOEi C 1 D AOEi c6
Pn
jD2.tj  1/
7 i D i 1 c7
Pn
jD2.tj  1/
8 AOEi C 1 D key c8 n  1
The running time of the algorithm is the sum of running times for each statement
executed; a statement that takes ci steps to execute and executes n times will
contribute cin to the total running time.6 To compute T .n/, the running time of
INSERTION-SORT on an input of n values, we sum the products of the cost and
times columns, obtaining
T .n/ D c1n C c2.n  1/ C c4.n  1/ C c5
Xn
jD2
tj C c6
Xn
jD2
.tj  1/
C c7
Xn
jD2
.tj  1/ C c8.n  1/ :
Even for inputs of a given size, an algorithmís running time may depend on
which input of that size is given. For example, in INSERTION-SORT, the best
case occurs if the array is already sorted. For each j D 2;3; : : : ;n, we then find
that AOEi  key in line 5 when i has its initial value of j  1. Thus tj D 1 for
j D 2;3; : : : ;n, and the best-case running time is
T .n/ D c1n C c2.n  1/ C c4.n  1/ C c5.n  1/ C c8.n  1/
D .c1 C c2 C c4 C c5 C c8/n  .c2 C c4 C c5 C c8/ :
We can express this running time as an C b for constants a and b that depend on
the statement costs ci; it is thus a linear function of n.
If the array is in reverse sorted orderóthat is, in decreasing orderóthe worst
case results. We must compare each element AOEj  with each element in the entire
sorted subarray AOE1 : : j  1, and so tj D j for j D 2;3; : : : ;n. Noting that
6This characteristic does not necessarily hold for a resource such as memory. A statement that
references m words of memory and is executed n times does not necessarily reference mn distinct
words of memory.2.2 Analyzing algorithms 27
Xn
jD2
j D
n.n C 1/
2
 1
and
Xn
jD2
.j  1/ D
n.n  1/
2
(see Appendix A for a review of how to solve these summations), we find that in
the worst case, the running time of INSERTION-SORT is
T .n/ D c1n C c2.n  1/ C c4.n  1/ C c5

n.n C 1/
2
 1

C c6

n.n  1/
2

C c7

n.n  1/
2

C c8.n  1/
D
c5
2
C
c6
2
C
c7
2

n2 C

c1 C c2 C c4 C
c5
2

c6
2

c7
2
C c8

n
 .c2 C c4 C c5 C c8/ :
We can express this worst-case running time as an2 C bn C c for constants a, b,
and c that again depend on the statement costs ci ; it is thus a quadratic function
of n.
Typically, as in insertion sort, the running time of an algorithm is fixed for a
given input, although in later chapters we shall see some interesting ìrandomizedî
algorithms whose behavior can vary even for a fixed input.
Worst-case and average-case analysis
In our analysis of insertion sort, we looked at both the best case, in which the input
array was already sorted, and the worst case, in which the input array was reverse
sorted. For the remainder of this book, though, we shall usually concentrate on
finding only the worst-case running time, that is, the longest running time for any
input of size n. We give three reasons for this orientation.
 The worst-case running time of an algorithm gives us an upper bound on the
running time for any input. Knowing it provides a guarantee that the algorithm
will never take any longer. We need not make some educated guess about the
running time and hope that it never gets much worse.
 For some algorithms, the worst case occurs fairly often. For example, in searching
a database for a particular piece of information, the searching algorithmís
worst case will often occur when the information is not present in the database.
In some applications, searches for absent information may be frequent.28 Chapter 2 Getting Started
 The ìaverage caseî is often roughly as bad as the worst case. Suppose that we
randomly choose n numbers and apply insertion sort. How long does it take to
determine where in subarray AOE1 : : j  1 to insert element AOEj ? On average,
half the elements in AOE1 : : j  1 are less than AOEj , and half the elements are
greater. On average, therefore, we check half of the subarray AOE1 : : j  1, and
so tj is about j=2. The resulting average-case running time turns out to be a
quadratic function of the input size, just like the worst-case running time.
In some particular cases, we shall be interested in the average-case running time
of an algorithm; we shall see the technique of probabilistic analysis applied to
various algorithms throughout this book. The scope of average-case analysis is
limited, because it may not be apparent what constitutes an ìaverageî input for
a particular problem. Often, we shall assume that all inputs of a given size are
equally likely. In practice, this assumption may be violated, but we can sometimes
use a randomized algorithm, which makes random choices, to allow a probabilistic
analysis and yield an expected running time. We explore randomized algorithms
more in Chapter 5 and in several other subsequent chapters.
Order of growth
We used some simplifying abstractions to ease our analysis of the INSERTIONSORT
procedure. First, we ignored the actual cost of each statement, using the
constants ci to represent these costs. Then, we observed that even these constants
give us more detail than we really need: we expressed the worst-case running time
as an2 C bn C c for some constants a, b, and c that depend on the statement
costs ci . We thus ignored not only the actual statement costs, but also the abstract
costs ci .
We shall now make one more simplifying abstraction: it is the rate of growth,
or order of growth, of the running time that really interests us. We therefore consider
only the leading term of a formula (e.g., an2), since the lower-order terms are
relatively insignificant for large values of n. We also ignore the leading termís constant
coefficient, since constant factors are less significant than the rate of growth
in determining computational efficiency for large inputs. For insertion sort, when
we ignore the lower-order terms and the leading termís constant coefficient, we are
left with the factor of n2 from the leading term. We write that insertion sort has a
worst-case running time of Ç.n2/ (pronounced ìtheta of n-squaredî). We shall use
Ç-notation informally in this chapter, and we will define it precisely in Chapter 3.
We usually consider one algorithm to be more efficient than another if its worstcase
running time has a lower order of growth. Due to constant factors and lowerorder
terms, an algorithm whose running time has a higher order of growth might
take less time for small inputs than an algorithm whose running time has a lower2.3 Designing algorithms 29
order of growth. But for large enough inputs, a Ç.n2/ algorithm, for example, will
run more quickly in the worst case than a Ç.n3/ algorithm.
Exercises
2.2-1
Express the function n3=1000  100n2  100n C 3 in terms of Ç-notation.
2.2-2
Consider sorting n numbers stored in array A by first finding the smallest element
of A and exchanging it with the element in AOE1. Then find the second smallest
element of A, and exchange it with AOE2. Continue in this manner for the first n1
elements of A. Write pseudocode for this algorithm, which is known as selection
sort. What loop invariant does this algorithm maintain? Why does it need to run
for only the first n  1 elements, rather than for all n elements? Give the best-case
and worst-case running times of selection sort in Ç-notation.
2.2-3
Consider linear search again (see Exercise 2.1-3). How many elements of the input
sequence need to be checked on the average, assuming that the element being
searched for is equally likely to be any element in the array? How about in the
worst case? What are the average-case and worst-case running times of linear
search in Ç-notation? Justify your answers.
2.2-4
How can we modify almost any algorithm to have a good best-case running time?
2.3 Designing algorithms
We can choose from a wide range of algorithm design techniques. For insertion
sort, we used an incremental approach: having sorted the subarray AOE1 : : j  1,
we inserted the single element AOEj  into its proper place, yielding the sorted
subarray AOE1 : : j .
In this section, we examine an alternative design approach, known as ìdivideand-
conquer,î which we shall explore in more detail in Chapter 4. Weíll use divideand-
conquer to design a sorting algorithm whose worst-case running time is much
less than that of insertion sort. One advantage of divide-and-conquer algorithms is
that their running times are often easily determined using techniques that we will
see in Chapter 4.30 Chapter 2 Getting Started
2.3.1 The divide-and-conquer approach
Many useful algorithms are recursive in structure: to solve a given problem, they
call themselves recursively one or more times to deal with closely related subproblems.
These algorithms typically follow a divide-and-conquer approach: they
break the problem into several subproblems that are similar to the original problem
but smaller in size, solve the subproblems recursively, and then combine these
solutions to create a solution to the original problem.
The divide-and-conquer paradigm involves three steps at each level of the recursion:
Divide the problem into a number of subproblems that are smaller instances of the
same problem.
Conquer the subproblems by solving them recursively. If the subproblem sizes are
small enough, however, just solve the subproblems in a straightforward manner.
Combine the solutions to the subproblems into the solution for the original problem.
The merge sort algorithm closely follows the divide-and-conquer paradigm. Intuitively,
it operates as follows.
Divide: Divide the n-element sequence to be sorted into two subsequences of n=2
elements each.
Conquer: Sort the two subsequences recursively using merge sort.
Combine: Merge the two sorted subsequences to produce the sorted answer.
The recursion ìbottoms outî when the sequence to be sorted has length 1, in which
case there is no work to be done, since every sequence of length 1 is already in
sorted order.
The key operation of the merge sort algorithm is the merging of two sorted
sequences in the ìcombineî step. We merge by calling an auxiliary procedure
MERGE.A; p; q; r/, where A is an array and p, q, and r are indices into the array
such that p  q < r. The procedure assumes that the subarrays AOEp : : q and
AOEq C 1: : r are in sorted order. It merges them to form a single sorted subarray
that replaces the current subarray AOEp : : r.
Our MERGE procedure takes time Ç.n/, where n D r  p C 1 is the total
number of elements being merged, and it works as follows. Returning to our cardplaying
motif, suppose we have two piles of cards face up on a table. Each pile is
sorted, with the smallest cards on top. We wish to merge the two piles into a single
sorted output pile, which is to be face down on the table. Our basic step consists
of choosing the smaller of the two cards on top of the face-up piles, removing it
from its pile (which exposes a new top card), and placing this card face down onto2.3 Designing algorithms 31
the output pile. We repeat this step until one input pile is empty, at which time
we just take the remaining input pile and place it face down onto the output pile.
Computationally, each basic step takes constant time, since we are comparing just
the two top cards. Since we perform at most n basic steps, merging takes Ç.n/
time.
The following pseudocode implements the above idea, but with an additional
twist that avoids having to check whether either pile is empty in each basic step.
We place on the bottom of each pile a sentinel card, which contains a special value
that we use to simplify our code. Here, we use 1 as the sentinel value, so that
whenever a card with1is exposed, it cannot be the smaller card unless both piles
have their sentinel cards exposed. But once that happens, all the nonsentinel cards
have already been placed onto the output pile. Since we know in advance that
exactly r  p C 1 cards will be placed onto the output pile, we can stop once we
have performed that many basic steps.
MERGE.A; p; q; r/
1 n1 D q  p C 1
2 n2 D r  q
3 letLOE1: : n1 C 1 and ROE1 : : n2 C 1 be new arrays
4 for i D 1 to n1
5 LOEi D AOEp C i  1
6 for j D 1 to n2
7 ROEj  D AOEq C j 
8 LOEn1 C 1 D 1
9 ROEn2 C 1 D 1
10 i D 1
11 j D 1
12 for k D p to r
13 if LOEi  ROEj 
14 AOEk D LOEi
15 i D i C 1
16 else AOEk D ROEj 
17 j D j C 1
In detail, the MERGE procedure works as follows. Line 1 computes the length n1
of the subarray AOEp : : q, and line 2 computes the length n2 of the subarray
AOEq C 1: : r. We create arrays L and R (ìleftî and ìrightî), of lengths n1 C 1
and n2 C 1, respectively, in line 3; the extra position in each array will hold the
sentinel. The for loop of lines 4ñ5 copies the subarray AOEp : : q into LOE1: : n1,
and the for loop of lines 6ñ7 copies the subarray AOEq C 1: : r into ROE1: : n2.
Lines 8ñ9 put the sentinels at the ends of the arrays L and R. Lines 10ñ17, illus32 Chapter 2 Getting Started
A
L R
1 2 3 4 1 2 3 4
i j
k
(a)
2 4 5 7 1 2 3 6
A
L R
1 2 3 4 1 2 3 4
i j
k
(b)
2 4 5 7
1
1 2 3 6
2 4 5 7 1 2 3 6 4 5 7 1 2 3 6
A
L R
9 10 11 12 13 14 15 16
1 2 3 4 1 2 3 4
i j
k
(c)
2 4 5 7
1
1 2 3 6
2 5 7 1 2 3 6 A
L R
1 2 3 4 1 2 3 4
i j
k
(d)
2 4 5 7
1
1 2 3 6
2 2 7 1 2 3 6
58
58
58
58
58
58
58
58
9 10 11 12 13 14 15 16
9 10 11 12 13 14 15 16
8 9 10 11 12 13 14 15 16
Ö
17
Ö
8
Ö
17
Ö
8
Ö
17
Ö
8
Ö
17
Ö
Figure 2.3 The operation of lines 10ñ17 in the call MERGE.A; 9; 12; 16/, when the subarray
AOE9 : : 16 contains the sequence h2; 4; 5; 7; 1; 2; 3; 6i. After copying and inserting sentinels, the
array L contains h2; 4; 5; 7; 1i, and the array R contains h1; 2; 3; 6; 1i. Lightly shaded positions
in A contain their final values, and lightly shaded positions in L and R contain values that have yet
to be copied back into A. Taken together, the lightly shaded positions always comprise the values
originally in AOE9 : : 16, along with the two sentinels. Heavily shaded positions in A contain values
that will be copied over, and heavily shaded positions in L and R contain values that have already
been copied back into A. (a)ñ(h) The arrays A, L, and R, and their respective indices k, i, and j
prior to each iteration of the loop of lines 12ñ17.
trated in Figure 2.3, perform the r pC1 basic steps by maintaining the following
loop invariant:
At the start of each iteration of the for loop of lines 12ñ17, the subarray
AOEp : : k  1 contains the k  p smallest elements of LOE1: : n1 C 1 and
ROE1 : : n2 C 1, in sorted order. Moreover, LOEi and ROEj  are the smallest
elements of their arrays that have not been copied back into A.
We must show that this loop invariant holds prior to the first iteration of the for
loop of lines 12ñ17, that each iteration of the loop maintains the invariant, and
that the invariant provides a useful property to show correctness when the loop
terminates.
Initialization: Prior to the first iteration of the loop, we have k D p, so that the
subarray AOEp : : k  1 is empty. This empty subarray contains the k  p D 0
smallest elements of L and R, and since i D j D 1, both LOEi and ROEj  are the
smallest elements of their arrays that have not been copied back into A.2.3 Designing algorithms 33
A
L R
1 2 3 4 1 2 3 4
i j
k
(e)
2 4 5 7
1
1 2 3 6
2 2 3 1 2 3 6 A
L R
1 2 3 4 1 2 3 4
i j
k
(f)
2 4 5 7
1
1 2 3 6
2 2 3 4 2 3 6
A
L R
1 2 3 4 1 2 3 4
i j
k
(g)
2 4 5 7
1
1 2 3 6
2 2 3 4 5 3 6 A
L R
1 2 3 4 1 2 3 4
i j
k
(h)
2 4 5 7
1
1 2 3 6
2 2 3 4 5 6
58
58
58
58
58
58
58
58
6
A
L R
1 2 3 4 1 2 3 4
i j
k
(i)
2 4 5 7
1
1 2 3 6
2 2 3 4 5 7
58
58
6
9 10 11 12 13 14 15 16
9 10 11 12 13 14 15 16
9 10 11 12 13 14 15 16
9 10 11 12 13 14 15 16
9 10 11 12 13 14 15 16
8
Ö
17
Ö
8
Ö
17
Ö
8
Ö
17
Ö
8
Ö
17
Ö
8
Ö
17
Ö
Figure 2.3, continued (i) The arrays and indices at termination. At this point, the subarray in
AOE9 : : 16 is sorted, and the two sentinels in L and R are the only two elements in these arrays that
have not been copied into A.
Maintenance: To see that each iteration maintains the loop invariant, let us first
suppose that LOEi  ROEj . Then LOEi is the smallest element not yet copied
back into A. Because AOEp : : k  1 contains the k  p smallest elements, after
line 14 copies LOEi into AOEk, the subarray AOEp : : k will contain the k  p C 1
smallest elements. Incrementing k (in the for loop update) and i (in line 15)
reestablishes the loop invariant for the next iteration. If instead LOEi > ROEj ,
then lines 16ñ17 perform the appropriate action to maintain the loop invariant.
Termination: At termination, k D r C 1. By the loop invariant, the subarray
AOEp : : k  1, which is AOEp : : r, contains the k  p D r  p C 1 smallest
elements of LOE1: : n1 C 1 and ROE1: : n2 C 1, in sorted order. The arrays L
and R together contain n1 C n2 C 2 D r  p C 3 elements. All but the two
largest have been copied back into A, and these two largest elements are the
sentinels.34 Chapter 2 Getting Started
To see that the MERGE procedure runs in Ç.n/ time, where n D r  p C 1,
observe that each of lines 1ñ3 and 8ñ11 takes constant time, the for loops of
lines 4ñ7 take Ç.n1 C n2/ D Ç.n/ time,7 and there are n iterations of the for
loop of lines 12ñ17, each of which takes constant time.
We can now use the MERGE procedure as a subroutine in the merge sort algorithm.
The procedure MERGE-SORT.A; p; r/ sorts the elements in the subarray
AOEp : : r. If p  r, the subarray has at most one element and is therefore
already sorted. Otherwise, the divide step simply computes an index q that partitions
AOEp : : r into two subarrays: AOEp : : q, containing dn=2e elements, and
AOEq C 1: : r, containing bn=2c elements.8
MERGE-SORT.A; p; r/
1 ifp < r
2 q D b.p C r/=2c
3 MERGE-SORT.A; p; q/
4 MERGE-SORT.A; q C 1; r/
5 MERGE.A; p; q; r/
To sort the entire sequence A D hAOE1; AOE2; : : : ; AOEni, we make the initial call
MERGE-SORT.A; 1;A:length/, where once again A:length D n. Figure 2.4 illustrates
the operation of the procedure bottom-up when n is a power of 2. The
algorithm consists of merging pairs of 1-item sequences to form sorted sequences
of length 2, merging pairs of sequences of length 2 to form sorted sequences of
length 4, and so on, until two sequences of length n=2 are merged to form the final
sorted sequence of length n.
2.3.2 Analyzing divide-and-conquer algorithms
When an algorithm contains a recursive call to itself, we can often describe its
running time by a recurrence equation or recurrence, which describes the overall
running time on a problem of size n in terms of the running time on smaller inputs.
We can then use mathematical tools to solve the recurrence and provide bounds on
the performance of the algorithm.
7We shall see in Chapter 3 how to formally interpret equations containing Ç-notation.
8The expression dxe denotes the least integer greater than or equal to x, and bxc denotes the greatest
integer less than or equal to x. These notations are defined in Chapter 3. The easiest way to verify
that setting q to b.p C r/=2c yields subarrays AOEp : : q and AOEq C 1 : : r of sizes dn=2e and bn=2c,
respectively, is to examine the four cases that arise depending on whether each of p and r is odd or
even.2.3 Designing algorithms 35
5 2 4 7 1 3 2 6
2 5 4 7 1 3 2 6
2 4 5 7 1 2 3 6
1 2 2 3 4 5 6 7
merge
merge
merge
sorted sequence
initial sequence
merge merge merge merge
Figure 2.4 The operation of merge sort on the array A D h5; 2; 4; 7; 1; 3; 2; 6i. The lengths of the
sorted sequences being merged increase as the algorithm progresses from bottom to top.
A recurrence for the running time of a divide-and-conquer algorithm falls out
from the three steps of the basic paradigm. As before, we let T .n/ be the running
time on a problem of size n. If the problem size is small enough, say n  c
for some constant c, the straightforward solution takes constant time, which we
write as Ç.1/. Suppose that our division of the problem yields a subproblems,
each of which is 1=b the size of the original. (For merge sort, both a and b are 2,
but we shall see many divide-and-conquer algorithms in which a § b.) It takes
time T .n=b/ to solve one subproblem of size n=b, and so it takes time aT .n=b/
to solve a of them. If we take D.n/ time to divide the problem into subproblems
and C.n/ time to combine the solutions to the subproblems into the solution to the
original problem, we get the recurrence
T .n/ D
(
Ç.1/ if n  c ;
aT .n=b/ C D.n/ C C.n/ otherwise :
In Chapter 4, we shall see how to solve common recurrences of this form.
Analysis of merge sort
Although the pseudocode for MERGE-SORT works correctly when the number of
elements is not even, our recurrence-based analysis is simplified if we assume that36 Chapter 2 Getting Started
the original problem size is a power of 2. Each divide step then yields two subsequences
of size exactly n=2. In Chapter 4, we shall see that this assumption does
not affect the order of growth of the solution to the recurrence.
We reason as follows to set up the recurrence for T .n/, the worst-case running
time of merge sort on n numbers. Merge sort on just one element takes constant
time. When we have n > 1 elements, we break down the running time as follows.
Divide: The divide step just computes the middle of the subarray, which takes
constant time. Thus, D.n/ D Ç.1/.
Conquer: We recursively solve two subproblems, each of size n=2, which contributes
2T .n=2/ to the running time.
Combine: We have already noted that the MERGE procedure on an n-element
subarray takes time Ç.n/, and so C.n/ D Ç.n/.
When we add the functions D.n/ and C.n/ for the merge sort analysis, we are
adding a function that is Ç.n/ and a function that is Ç.1/. This sum is a linear
function of n, that is, Ç.n/. Adding it to the 2T .n=2/ term from the ìconquerî
step gives the recurrence for the worst-case running time T .n/ of merge sort:
T .n/ D
(
Ç.1/ if n D 1 ;
2T .n=2/ C Ç.n/ if n > 1 :
(2.1)
In Chapter 4, we shall see the ìmaster theorem,î which we can use to show
that T .n/ is Ç.n lg n/, where lg n stands for log2 n. Because the logarithm function
grows more slowly than any linear function, for large enough inputs, merge
sort, with its Ç.n lg n/ running time, outperforms insertion sort, whose running
time is Ç.n2/, in the worst case.
We do not need the master theorem to intuitively understand why the solution to
the recurrence (2.1) is T .n/ D Ç.n lg n/. Let us rewrite recurrence (2.1) as
T .n/ D
(
c if n D 1 ;
2T .n=2/ C cn if n > 1 ;
(2.2)
where the constant c represents the time required to solve problems of size 1 as
well as the time per array element of the divide and combine steps.9
9It is unlikely that the same constant exactly represents both the time to solve problems of size 1
and the time per array element of the divide and combine steps. We can get around this problem by
letting c be the larger of these times and understanding that our recurrence gives an upper bound on
the running time, or by letting c be the lesser of these times and understanding that our recurrence
gives a lower bound on the running time. Both bounds are on the order of n lg n and, taken together,
give a Ç.n lg n/ running time.2.3 Designing algorithms 37
Figure 2.5 shows how we can solve recurrence (2.2). For convenience, we assume
that n is an exact power of 2. Part (a) of the figure shows T .n/, which we
expand in part (b) into an equivalent tree representing the recurrence. The cn term
is the root (the cost incurred at the top level of recursion), and the two subtrees of
the root are the two smaller recurrences T .n=2/. Part (c) shows this process carried
one step further by expanding T .n=2/. The cost incurred at each of the two subnodes
at the second level of recursion is cn=2. We continue expanding each node
in the tree by breaking it into its constituent parts as determined by the recurrence,
until the problem sizes get down to 1, each with a cost of c. Part (d) shows the
resulting recursion tree.
Next, we add the costs across each level of the tree. The top level has total
cost cn, the next level down has total cost c.n=2/ C c.n=2/ D cn, the level after
that has total cost c.n=4/Cc.n=4/Cc.n=4/Cc.n=4/ D cn, and so on. In general,
the level i below the top has 2i nodes, each contributing a cost of c.n=2i /, so that
the i th level below the top has total cost 2i c.n=2i / D cn. The bottom level has n
nodes, each contributing a cost of c, for a total cost of cn.
The total number of levels of the recursion tree in Figure 2.5 is lg n C 1, where
n is the number of leaves, corresponding to the input size. An informal inductive
argument justifies this claim. The base case occurs when n D 1, in which case the
tree has only one level. Since lg 1 D 0, we have that lgn C 1 gives the correct
number of levels. Now assume as an inductive hypothesis that the number of levels
of a recursion tree with 2i leaves is lg 2i C 1 D i C 1 (since for any value of i ,
we have that lg 2i D i ). Because we are assuming that the input size is a power
of 2, the next input size to consider is 2iC1. A tree with n D 2iC1 leaves has
one more level than a tree with 2i leaves, and so the total number of levels is
.i C 1/ C 1 D lg 2iC1 C 1.
To compute the total cost represented by the recurrence (2.2), we simply add up
the costs of all the levels. The recursion tree has lg n C 1 levels, each costing cn,
for a total cost of cn.lg n C 1/ D cn lg n C cn. Ignoring the low-order term and
the constant c gives the desired result of Ç.n lg n/.
Exercises
2.3-1
Using Figure 2.4 as a model, illustrate the operation of merge sort on the array
A D h3; 41; 52; 26; 38; 57; 9; 49i.
2.3-2
Rewrite the MERGE procedure so that it does not use sentinels, instead stopping
once either array L or R has had all its elements copied back to A and then copying
the remainder of the other array back into A.38 Chapter 2 Getting Started
cn
cn
Ö
Total: cn lg n + cn
cn
lg n
cn
n
c c c c c c c
Ö
(d)
(c)
cn
T(n/2) T(n/2)
(b)
T(n)
(a)
cn
cn/2
T(n/4) T(n/4)
cn/2
T(n/4) T(n/4)
cn
cn/2
cn/4 cn/4
cn/2
cn/4 cn/4
Figure 2.5 How to construct a recursion tree for the recurrence T .n/ D 2T .n=2/ C cn.
Part (a) shows T .n/, which progressively expands in (b)ñ(d) to form the recursion tree. The fully
expanded tree in part (d) has lg n C 1 levels (i.e., it has height lg n, as indicated), and each level
contributes a total cost of cn. The total cost, therefore, is cn lg n C cn, which is Ç.n lg n/.Problems for Chapter 2 39
2.3-3
Use mathematical induction to show that when n is an exact power of 2, the solution
of the recurrence
T .n/ D
(
2 if n D 2 ;
2T .n=2/ C n if n D 2k, for k > 1
is T .n/ D n lg n.
2.3-4
We can express insertion sort as a recursive procedure as follows. In order to sort
AOE1 : : n, we recursively sort AOE1 : : n1 and then insert AOEn into the sorted array
AOE1 : : n  1. Write a recurrence for the running time of this recursive version of
insertion sort.
2.3-5
Referring back to the searching problem (see Exercise 2.1-3), observe that if the
sequence A is sorted, we can check the midpoint of the sequence against  and
eliminate half of the sequence from further consideration. The binary search algorithm
repeats this procedure, halving the size of the remaining portion of the
sequence each time. Write pseudocode, either iterative or recursive, for binary
search. Argue that the worst-case running time of binary search is Ç.lg n/.
2.3-6
Observe that the while loop of lines 5ñ7 of the INSERTION-SORT procedure in
Section 2.1 uses a linear search to scan (backward) through the sorted subarray
AOE1 : : j  1. Can we use a binary search (see Exercise 2.3-5) instead to improve
the overall worst-case running time of insertion sort to Ç.n lg n/?
2.3-7 ?
Describe a Ç.n lg n/-time algorithm that, given a set S of n integers and another
integer x, determines whether or not there exist two elements in S whose sum is
exactly x.
Problems
2-1 Insertion sort on small arrays in merge sort
Although merge sort runs in Ç.n lg n/ worst-case time and insertion sort runs
in Ç.n2/ worst-case time, the constant factors in insertion sort can make it faster
in practice for small problem sizes on many machines. Thus, it makes sense to
coarsen the leaves of the recursion by using insertion sort within merge sort when40 Chapter 2 Getting Started
subproblems become sufficiently small. Consider a modification to merge sort in
which n=k sublists of length k are sorted using insertion sort and then merged
using the standard merging mechanism, where k is a value to be determined.
a. Show that insertion sort can sort the n=k sublists, each of length k, in Ç.nk/
worst-case time.
b. Show how to merge the sublists in Ç.n lg.n=k// worst-case time.
c. Given that the modified algorithm runs in Ç.nk C n lg.n=k// worst-case time,
what is the largest value of k as a function of n for which the modified algorithm
has the same running time as standard merge sort, in terms of Ç-notation?
d. How should we choose k in practice?
2-2 Correctness of bubblesort
Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly
swapping adjacent elements that are out of order.
BUBBLESORT.A/
1 for i D 1 to A:length  1
2 for j D A:length downto i C 1
3 if AOEj  < AOEj  1
4 exchange AOEj  with AOEj  1
a. Let A0 denote the output of BUBBLESORT.A/. To prove that BUBBLESORT is
correct, we need to prove that it terminates and that
A0OE1  A0OE2      A0OEn ; (2.3)
where n D A:length. In order to show that BUBBLESORT actually sorts, what
else do we need to prove?
The next two parts will prove inequality (2.3).
b. State precisely a loop invariant for the for loop in lines 2ñ4, and prove that this
loop invariant holds. Your proof should use the structure of the loop invariant
proof presented in this chapter.
c. Using the termination condition of the loop invariant proved in part (b), state
a loop invariant for the for loop in lines 1ñ4 that will allow you to prove inequality
(2.3). Your proof should use the structure of the loop invariant proof
presented in this chapter.Problems for Chapter 2 41
d. What is the worst-case running time of bubblesort? How does it compare to the
running time of insertion sort?
2-3 Correctness of Hornerís rule
The following code fragment implements Hornerís rule for evaluating a polynomial
P.x/ D
Xn
kD0
akxk
D a0 C x.a1 C x.a2 C  Cx.an1 C xan/   // ;
given the coefficients a0; a1; : : : ;an and a value for x:
1 y D 0
2 for i D n downto 0
3 y D ai C x  y
a. In terms of Ç-notation, what is the running time of this code fragment for
Hornerís rule?
b. Write pseudocode to implement the naive polynomial-evaluation algorithm that
computes each term of the polynomial from scratch. What is the running time
of this algorithm? How does it compare to Hornerís rule?
c. Consider the following loop invariant:
At the start of each iteration of the for loop of lines 2ñ3,
y D
nX.iC1/
kD0
akCiC1xk :
Interpret a summation with no terms as equaling 0. Following the structure of
the loop invariant proof presented in this chapter, use this loop invariant to show
that, at termination, y D
Pn
kD0 akxk.
d. Conclude by arguing that the given code fragment correctly evaluates a polynomial
characterized by the coefficients a0; a1; : : : ;an.
2-4 Inversions
Let AOE1 : : n be an array of n distinct numbers. If i < j and AOEi > AOEj , then the
pair .i; j / is called an inversion of A.
a. List the five inversions of the array h2; 3; 8; 6; 1i.42 Chapter 2 Getting Started
b. What array with elements from the set f1;2; : : : ;ng has the most inversions?
How many does it have?
c. What is the relationship between the running time of insertion sort and the
number of inversions in the input array? Justify your answer.
d. Give an algorithm that determines the number of inversions in any permutation
on n elements in Ç.n lg n/ worst-case time. (Hint: Modify merge sort.)
Chapter notes
In 1968, Knuth published the first of three volumes with the general title The Art of
Computer Programming [209, 210, 211]. The first volume ushered in the modern
study of computer algorithms with a focus on the analysis of running time, and the
full series remains an engaging and worthwhile reference for many of the topics
presented here. According to Knuth, the word ìalgorithmî is derived from the
name ìal-Khowàarizmài,î a ninth-century Persian mathematician.
Aho, Hopcroft, and Ullman [5] advocated the asymptotic analysis of algorithmsó
using notations that Chapter 3 introduces, including Ç-notationóas a
means of comparing relative performance. They also popularized the use of recurrence
relations to describe the running times of recursive algorithms.
Knuth [211] provides an encyclopedic treatment of many sorting algorithms. His
comparison of sorting algorithms (page 381) includes exact step-counting analyses,
like the one we performed here for insertion sort. Knuthís discussion of insertion
sort encompasses several variations of the algorithm. The most important of these
is Shellís sort, introduced by D. L. Shell, which uses insertion sort on periodic
subsequences of the input to produce a faster sorting algorithm.
Merge sort is also described by Knuth. He mentions that a mechanical collator
capable of merging two decks of punched cards in a single pass was invented
in 1938. J. von Neumann, one of the pioneers of computer science, apparently
wrote a program for merge sort on the EDVAC computer in 1945.
The early history of proving programs correct is described by Gries [153], who
credits P. Naur with the first article in this field. Gries attributes loop invariants to
R. W. Floyd. The textbook by Mitchell [256] describes more recent progress in
proving programs correct.3 Growth of Functions
The order of growth of the running time of an algorithm, defined in Chapter 2,
gives a simple characterization of the algorithmís efficiency and also allows us to
compare the relative performance of alternative algorithms. Once the input size n
becomes large enough, merge sort, with its Ç.n lg n/ worst-case running time,
beats insertion sort, whose worst-case running time is Ç.n2/. Although we can
sometimes determine the exact running time of an algorithm, as we did for insertion
sort in Chapter 2, the extra precision is not usually worth the effort of computing
it. For large enough inputs, the multiplicative constants and lower-order terms of
an exact running time are dominated by the effects of the input size itself.
When we look at input sizes large enough to make only the order of growth of
the running time relevant, we are studying the asymptotic efficiency of algorithms.
That is, we are concerned with how the running time of an algorithm increases with
the size of the input in the limit, as the size of the input increases without bound.
Usually, an algorithm that is asymptotically more efficient will be the best choice
for all but very small inputs.
This chapter gives several standard methods for simplifying the asymptotic analysis
of algorithms. The next section begins by defining several types of ìasymptotic
notation,î of which we have already seen an example in Ç-notation. We then
present several notational conventions used throughout this book, and finally we
review the behavior of functions that commonly arise in the analysis of algorithms.
3.1 Asymptotic notation
The notations we use to describe the asymptotic running time of an algorithm
are defined in terms of functions whose domains are the set of natural numbers
N D f0; 1; 2; : : :g. Such notations are convenient for describing the worst-case
running-time function T .n/, which usually is defined only on integer input sizes.
We sometimes find it convenient, however, to abuse asymptotic notation in a va44 Chapter 3 Growth of Functions
riety of ways. For example, we might extend the notation to the domain of real
numbers or, alternatively, restrict it to a subset of the natural numbers. We should
make sure, however, to understand the precise meaning of the notation so that when
we abuse, we do not misuse it. This section defines the basic asymptotic notations
and also introduces some common abuses.
Asymptotic notation, functions, and running times
We will use asymptotic notation primarily to describe the running times of algorithms,
as when we wrote that insertion sortís worst-case running time is Ç.n2/.
Asymptotic notation actually applies to functions, however. Recall that we characterized
insertion sortís worst-case running time as an2CbnCc, for some constants
a, b, and c. By writing that insertion sortís running time is Ç.n2/, we abstracted
away some details of this function. Because asymptotic notation applies to functions,
what we were writing as Ç.n2/ was the function an2 C bn C c, which in
that case happened to characterize the worst-case running time of insertion sort.
In this book, the functions to which we apply asymptotic notation will usually
characterize the running times of algorithms. But asymptotic notation can apply to
functions that characterize some other aspect of algorithms (the amount of space
they use, for example), or even to functions that have nothing whatsoever to do
with algorithms.
Even when we use asymptotic notation to apply to the running time of an algorithm,
we need to understand which running time we mean. Sometimes we are
interested in the worst-case running time. Often, however, we wish to characterize
the running time no matter what the input. In other words, we often wish to make
a blanket statement that covers all inputs, not just the worst case. We shall see
asymptotic notations that are well suited to characterizing running times no matter
what the input.
Ç-notation
In Chapter 2, we found that the worst-case running time of insertion sort is
T .n/ D Ç.n2/. Let us define what this notation means. For a given function g.n/,
we denote by Ç.g.n// the set of functions
Ç.g.n// D ff .n/ W there exist positive constants c1, c2, and n0 such that
0  c1g.n/  f .n/  c2g.n/ for all n  n0g :1
1Within set notation, a colon means ìsuch that.î3.1 Asymptotic notation 45
(a) (b) (c)
n n n
n0 n0 n0
f .n/ D Ç.g.n// f .n/ D O.g.n// f .n/ D .g.n//
f .n/
f .n/
f .n/
cg.n/
cg.n/
c1g.n/
c2g.n/
Figure 3.1 Graphic examples of the Ç, O, and  notations. In each part, the value of n0 shown
is the minimum possible value; any greater value would also work. (a) Ç-notation bounds a function
to within constant factors. We write f .n/ D Ç.g.n// if there exist positive constants n0, c1,
and c2 such that at and to the right of n0, the value of f .n/ always lies between c1g.n/ and c2g.n/
inclusive. (b) O-notation gives an upper bound for a function to within a constant factor. We write
f .n/ D O.g.n// if there are positive constants n0 and c such that at and to the right of n0, the value
of f .n/ always lies on or below cg.n/. (c) -notation gives a lower bound for a function to within
a constant factor. We write f .n/ D .g.n// if there are positive constants n0 and c such that at and
to the right of n0, the value of f .n/ always lies on or above cg.n/.
A function f .n/ belongs to the set Ç.g.n// if there exist positive constants c1
and c2 such that it can be ìsandwichedî between c1g.n/ and c2g.n/, for sufficiently
large n. Because Ç.g.n// is a set, we could write ìf .n/ 2 Ç.g.n//î
to indicate that f .n/ is a member of Ç.g.n//. Instead, we will usually write
ìf .n/ D Ç.g.n//î to express the same notion. You might be confused because
we abuse equality in this way, but we shall see later in this section that doing so
has its advantages.
Figure 3.1(a) gives an intuitive picture of functions f .n/ and g.n/, where
f .n/ D Ç.g.n//. For all values of n at and to the right of n0, the value of f .n/
lies at or above c1g.n/ and at or below c2g.n/. In other words, for all n  n0, the
function f .n/ is equal to g.n/ to within a constant factor. We say that g.n/ is an
asymptotically tight bound for f .n/.
The definition of Ç.g.n// requires that every member f .n/ 2 Ç.g.n// be
asymptotically nonnegative, that is, that f .n/ be nonnegative whenever n is sufficiently
large. (An asymptotically positive function is one that is positive for all
sufficiently large n.) Consequently, the function g.n/ itself must be asymptotically
nonnegative, or else the set Ç.g.n// is empty. We shall therefore assume that every
function used within Ç-notation is asymptotically nonnegative. This assumption
holds for the other asymptotic notations defined in this chapter as well.46 Chapter 3 Growth of Functions
In Chapter 2, we introduced an informal notion of Ç-notation that amounted
to throwing away lower-order terms and ignoring the leading coefficient of the
highest-order term. Let us briefly justify this intuition by using the formal definition
to show that 1
2n2  3n D Ç.n2/. To do so, we must determine positive
constants c1, c2, and n0 such that
c1n2 
1
2
n2  3n  c2n2
for all n  n0. Dividing by n2 yields
c1 
1
2

3
n
 c2 :
We can make the right-hand inequality hold for any value of n  1 by choosing any
constant c2  1=2. Likewise, we can make the left-hand inequality hold for any
value of n  7 by choosing any constant c1  1=14. Thus, by choosing c1 D 1=14,
c2 D 1=2, and n0 D 7, we can verify that 1
2n2  3n D Ç.n2/. Certainly, other
choices for the constants exist, but the important thing is that some choice exists.
Note that these constants depend on the function 1
2n2  3n; a different function
belonging to Ç.n2/ would usually require different constants.
We can also use the formal definition to verify that 6n3 § Ç.n2/. Suppose
for the purpose of contradiction that c2 and n0 exist such that 6n3  c2n2 for
all n  n0. But then dividing by n2 yields n  c2=6, which cannot possibly hold
for arbitrarily large n, since c2 is constant.
Intuitively, the lower-order terms of an asymptotically positive function can be
ignored in determining asymptotically tight bounds because they are insignificant
for large n. When n is large, even a tiny fraction of the highest-order term suffices
to dominate the lower-order terms. Thus, setting c1 to a value that is slightly
smaller than the coefficient of the highest-order term and setting c2 to a value that
is slightly larger permits the inequalities in the definition of Ç-notation to be satisfied.
The coefficient of the highest-order term can likewise be ignored, since it
only changes c1 and c2 by a constant factor equal to the coefficient.
As an example, consider any quadratic function f .n/ D an2 C bn C c, where
a, b, and c are constants and a > 0. Throwing away the lower-order terms and
ignoring the constant yields f .n/ D Ç.n2/. Formally, to show the same thing, we
take the constants c1 D a=4, c2 D 7a=4, and n0 D 2  max.jbj =a;
p
jcj =a/. You
may verify that 0  c1n2  an2 C bn C c  c2n2 for all n  n0. In general,
for any polynomial p.n/ D
Pd
iD0 aini , where the ai are constants and ad > 0, we
have p.n/ D Ç.nd / (see Problem 3-1).
Since any constant is a degree-0 polynomial, we can express any constant function
as Ç.n0/, or Ç.1/. This latter notation is a minor abuse, however, because the3.1 Asymptotic notation 47
expression does not indicate what variable is tending to infinity.2 We shall often
use the notation Ç.1/ to mean either a constant or a constant function with respect
to some variable.
O-notation
The Ç-notation asymptotically bounds a function from above and below. When
we have only an asymptotic upper bound, we use O-notation. For a given function
g.n/, we denote by O.g.n// (pronounced ìbig-oh of g of nî or sometimes
just ìoh of g of nî) the set of functions
O.g.n// D ff .n/ W there exist positive constants c and n0 such that
0  f .n/  cg.n/ for all n  n0g :
We use O-notation to give an upper bound on a function, to within a constant
factor. Figure 3.1(b) shows the intuition behind O-notation. For all values n at and
to the right of n0, the value of the function f .n/ is on or below cg.n/.
We write f .n/ D O.g.n// to indicate that a function f .n/ is a member of the
set O.g.n//. Note that f .n/ D Ç.g.n// implies f .n/ D O.g.n//, since Ç-
notation is a stronger notion than O-notation. Written set-theoretically, we have
Ç.g.n//  O.g.n//. Thus, our proof that any quadratic function an2 C bn C c,
where a > 0, is in Ç.n2/ also shows that any such quadratic function is in O.n2/.
What may be more surprising is that when a > 0, any linear function an C b is
in O.n2/, which is easily verified by taking c D a C jbj and n0 D max.1;b=a/.
If you have seen O-notation before, you might find it strange that we should
write, for example, n D O.n2/. In the literature, we sometimes find O-notation
informally describing asymptotically tight bounds, that is, what we have defined
using Ç-notation. In this book, however, when we write f .n/ D O.g.n//, we
are merely claiming that some constant multiple of g.n/ is an asymptotic upper
bound on f .n/, with no claim about how tight an upper bound it is. Distinguishing
asymptotic upper bounds from asymptotically tight bounds is standard in the
algorithms literature.
Using O-notation, we can often describe the running time of an algorithm
merely by inspecting the algorithmís overall structure. For example, the doubly
nested loop structure of the insertion sort algorithm from Chapter 2 immediately
yields an O.n2/ upper bound on the worst-case running time: the cost of each iteration
of the inner loop is bounded from above by O.1/ (constant), the indices i
2The real problem is that our ordinary notation for functions does not distinguish functions from
values. In -calculus, the parameters to a function are clearly specified: the function n2 could be
written as n:n2, or even r:r2. Adopting a more rigorous notation, however, would complicate
algebraic manipulations, and so we choose to tolerate the abuse.48 Chapter 3 Growth of Functions
and j are both at most n, and the inner loop is executed at most once for each of
the n2 pairs of values for i and j .
Since O-notation describes an upper bound, when we use it to bound the worstcase
running time of an algorithm, we have a bound on the running time of the algorithm
on every inputóthe blanket statement we discussed earlier. Thus, the O.n2/
bound on worst-case running time of insertion sort also applies to its running time
on every input. The Ç.n2/ bound on the worst-case running time of insertion sort,
however, does not imply a Ç.n2/ bound on the running time of insertion sort on
every input. For example, we saw in Chapter 2 that when the input is already
sorted, insertion sort runs in Ç.n/ time.
Technically, it is an abuse to say that the running time of insertion sort is O.n2/,
since for a given n, the actual running time varies, depending on the particular
input of size n. When we say ìthe running time is O.n2/,î we mean that there is a
function f .n/ that is O.n2/ such that for any value of n, no matter what particular
input of size n is chosen, the running time on that input is bounded from above by
the value f .n/. Equivalently, we mean that the worst-case running time is O.n2/.
-notation
Just as O-notation provides an asymptotic upper bound on a function, -notation
provides an asymptotic lower bound. For a given function g.n/, we denote
by .g.n// (pronounced ìbig-omega of g of nî or sometimes just ìomega of g
of nî) the set of functions
.g.n// D ff .n/ W there exist positive constants c and n0 such that
0  cg.n/  f .n/ for all n  n0g :
Figure 3.1(c) shows the intuition behind -notation. For all values n at or to the
right of n0, the value of f .n/ is on or above cg.n/.
From the definitions of the asymptotic notations we have seen thus far, it is easy
to prove the following important theorem (see Exercise 3.1-5).
Theorem 3.1
For any two functions f .n/ and g.n/, we have f .n/ D Ç.g.n// if and only if
f .n/ D O.g.n// and f .n/ D .g.n//.
As an example of the application of this theorem, our proof that an2 C bn C cD
Ç.n2/ for any constants a, b, and c, where a > 0, immediately implies that
an2 C bn C c D .n2/ and an2CbnCc D O.n2/. In practice, rather than using
Theorem 3.1 to obtain asymptotic upper and lower bounds from asymptotically
tight bounds, as we did for this example, we usually use it to prove asymptotically
tight bounds from asymptotic upper and lower bounds.3.1 Asymptotic notation 49
When we say that the running time (no modifier) of an algorithm is .g.n//,
we mean that no matter what particular input of size n is chosen for each value
of n, the running time on that input is at least a constant times g.n/, for sufficiently
large n. Equivalently, we are giving a lower bound on the best-case running time
of an algorithm. For example, the best-case running time of insertion sort is .n/,
which implies that the running time of insertion sort is .n/.
The running time of insertion sort therefore belongs to both .n/ and O.n2/,
since it falls anywhere between a linear function of n and a quadratic function of n.
Moreover, these bounds are asymptotically as tight as possible: for instance, the
running time of insertion sort is not .n2/, since there exists an input for which
insertion sort runs in Ç.n/ time (e.g., when the input is already sorted). It is not
contradictory, however, to say that the worst-case running time of insertion sort
is .n2/, since there exists an input that causes the algorithm to take .n2/ time.
Asymptotic notation in equations and inequalities
We have already seen how asymptotic notation can be used within mathematical
formulas. For example, in introducing O-notation, we wrote ìn D O.n2/.î We
might also write 2n2C3nC1 D 2n2CÇ.n/. How do we interpret such formulas?
When the asymptotic notation stands alone (that is, not within a larger formula)
on the right-hand side of an equation (or inequality), as in n D O.n2/, we have
already defined the equal sign to mean set membership: n 2 O.n2/. In general,
however, when asymptotic notation appears in a formula, we interpret it as standing
for some anonymous function that we do not care to name. For example, the
formula 2n2 C 3n C 1 D 2n2 C Ç.n/ means that 2n2 C 3n C 1 D 2n2 C f .n/,
where f .n/ is some function in the set Ç.n/. In this case, we let f .n/ D 3n C 1,
which indeed is in Ç.n/.
Using asymptotic notation in this manner can help eliminate inessential detail
and clutter in an equation. For example, in Chapter 2 we expressed the worst-case
running time of merge sort as the recurrence
T .n/ D 2T .n=2/ C Ç.n/ :
If we are interested only in the asymptotic behavior of T .n/, there is no point in
specifying all the lower-order terms exactly; they are all understood to be included
in the anonymous function denoted by the term Ç.n/.
The number of anonymous functions in an expression is understood to be equal
to the number of times the asymptotic notation appears. For example, in the expression
Xn
iD1
O.i/ ;50 Chapter 3 Growth of Functions
there is only a single anonymous function (a function of i ). This expression is thus
not the same as O.1/ C O.2/ C    C O.n/, which doesnít really have a clean
interpretation.
In some cases, asymptotic notation appears on the left-hand side of an equation,
as in
2n2 C Ç.n/ D Ç.n2/ :
We interpret such equations using the following rule: No matter how the anonymous
functions are chosen on the left of the equal sign, there is a way to choose
the anonymous functions on the right of the equal sign to make the equation valid.
Thus, our example means that for any function f .n/ 2 Ç.n/, there is some function
g.n/ 2 Ç.n2/ such that 2n2 C f .n/ D g.n/ for all n. In other words, the
right-hand side of an equation provides a coarser level of detail than the left-hand
side.
We can chain together a number of such relationships, as in
2n2 C 3n C 1 D 2n2 C Ç.n/
D Ç.n2/ :
We can interpret each equation separately by the rules above. The first equation
says that there is some function f .n/ 2 Ç.n/ such that 2n2 C 3n C 1 D
2n2 C f .n/ for all n. The second equation says that for any function g.n/ 2 Ç.n/
(such as the f .n/ just mentioned), there is some function h.n/ 2 Ç.n2/ such
that 2n2 C g.n/ D h.n/ for all n. Note that this interpretation implies that
2n2 C 3n C 1 D Ç.n2/, which is what the chaining of equations intuitively gives
us.
o-notation
The asymptotic upper bound provided by O-notation may or may not be asymptotically
tight. The bound 2n2 D O.n2/ is asymptotically tight, but the bound
2n D O.n2/ is not. We use o-notation to denote an upper bound that is not asymptotically
tight. We formally define o.g.n// (ìlittle-oh of g of nî) as the set
o.g.n// D ff .n/ W for any positive constant c > 0, there exists a constant
n0 > 0 such that 0  f .n/ < cg.n/ for all n  n0g :
For example, 2n D o.n2/, but 2n2 § o.n2/.
The definitions of O-notation and o-notation are similar. The main difference
is that in f .n/ D O.g.n//, the bound 0  f .n/  cg.n/ holds for some constant
c > 0, but in f .n/ D o.g.n//, the bound 0  f .n/ < cg.n/ holds for all
constants c > 0. Intuitively, in o-notation, the function f .n/ becomes insignificant
relative to g.n/ as n approaches infinity; that is,3.1 Asymptotic notation 51
lim
n!1
f .n/
g.n/
D 0 : (3.1)
Some authors use this limit as a definition of the o-notation; the definition in this
book also restricts the anonymous functions to be asymptotically nonnegative.
!-notation
By analogy, !-notation is to -notation as o-notation is to O-notation. We use
!-notation to denote a lower bound that is not asymptotically tight. One way to
define it is by
f .n/ 2 !.g.n// if and only if g.n/ 2 o.f .n// :
Formally, however, we define !.g.n// (ìlittle-omega of g of nî) as the set
!.g.n// D ff .n/ W for any positive constant c > 0, there exists a constant
n0 > 0 such that 0  cg.n/ < f .n/ for all n  n0g :
For example, n2=2 D !.n/, but n2=2 § !.n2/. The relation f .n/ D !.g.n//
implies that
lim
n!1
f .n/
g.n/
D1;
if the limit exists. That is, f .n/ becomes arbitrarily large relative to g.n/ as n
approaches infinity.
Comparing functions
Many of the relational properties of real numbers apply to asymptotic comparisons
as well. For the following, assume that f .n/ and g.n/ are asymptotically positive.
Transitivity:
f .n/ D Ç.g.n// and g.n/ D Ç.h.n// imply f .n/ D Ç.h.n// ;
f .n/ D O.g.n// and g.n/ D O.h.n// imply f .n/ D O.h.n// ;
f .n/ D .g.n// and g.n/ D .h.n// imply f .n/ D .h.n// ;
f .n/ D o.g.n// and g.n/ D o.h.n// imply f .n/ D o.h.n// ;
f .n/ D !.g.n// and g.n/ D !.h.n// imply f .n/ D !.h.n// :
Reflexivity:
f .n/ D Ç.f .n// ;
f .n/ D O.f .n// ;
f .n/ D .f .n// :52 Chapter 3 Growth of Functions
Symmetry:
f .n/ D Ç.g.n// if and only if g.n/ D Ç.f .n// :
Transpose symmetry:
f .n/ D O.g.n// if and only if g.n/ D .f .n// ;
f .n/ D o.g.n// if and only if g.n/ D !.f .n// :
Because these properties hold for asymptotic notations, we can draw an analogy
between the asymptotic comparison of two functions f and g and the comparison
of two real numbers a and b:
f .n/ D O.g.n// is like a  b ;
f .n/ D .g.n// is like a  b ;
f .n/ D Ç.g.n// is like a D b ;
f .n/ D o.g.n// is like a < b ;
f .n/ D !.g.n// is like a > b :
We say that f .n/ is asymptotically smaller than g.n/ if f .n/ D o.g.n//, and f .n/
is asymptotically larger than g.n/ if f .n/ D !.g.n//.
One property of real numbers, however, does not carry over to asymptotic notation:
Trichotomy: For any two real numbers a and b, exactly one of the following must
hold: a < b, a D b, or a > b.
Although any two real numbers can be compared, not all functions are asymptotically
comparable. That is, for two functions f .n/ and g.n/, it may be the case
that neither f .n/ D O.g.n// nor f .n/ D .g.n// holds. For example, we cannot
compare the functions n and n1Csinn using asymptotic notation, since the value of
the exponent in n1Csinn oscillates between 0 and 2, taking on all values in between.
Exercises
3.1-1
Let f .n/ and g.n/ be asymptotically nonnegative functions. Using the basic definition
of Ç-notation, prove that max.f .n/; g.n// D Ç.f .n/ C g.n//.
3.1-2
Show that for any real constants a and b, where b > 0,
.n C a/b D Ç.nb/ : (3.2)3.2 Standard notations and common functions 53
3.1-3
Explain why the statement, ìThe running time of algorithm A is at least O.n2/,î is
meaningless.
3.1-4
Is 2nC1 D O.2n/? Is 22n D O.2n/?
3.1-5
Prove Theorem 3.1.
3.1-6
Prove that the running time of an algorithm is Ç.g.n// if and only if its worst-case
running time is O.g.n// and its best-case running time is .g.n//.
3.1-7
Prove that o.g.n// \ !.g.n// is the empty set.
3.1-8
We can extend our notation to the case of two parameters n and m that can go to
infinity independently at different rates. For a given function g.n;m/, we denote
by O.g.n;m// the set of functions
O.g.n;m// D ff .n;m/ W there exist positive constants c, n0, and m0
such that 0  f .n;m/  cg.n;m/
for all n  n0 or m  m0g :
Give corresponding definitions for .g.n;m// and Ç.g.n;m//.
3.2 Standard notations and common functions
This section reviews some standard mathematical functions and notations and explores
the relationships among them. It also illustrates the use of the asymptotic
notations.
Monotonicity
A function f .n/ is monotonically increasing if m  n implies f .m/  f .n/.
Similarly, it is monotonically decreasing if m  n implies f .m/  f .n/. A
function f .n/ is strictly increasing if m < n implies f .m/ < f .n/ and strictly
decreasing if m < nimplies f .m/ > f .n/.54 Chapter 3 Growth of Functions
Floors and ceilings
For any real number x, we denote the greatest integer less than or equal to x by bxc
(read ìthe floor of xî) and the least integer greater than or equal to x by dxe (read
ìthe ceiling of xî). For all real x,
x 1 < bxc  x  dxe < xC 1 : (3.3)
For any integer n,
dn=2e C bn=2c D n ;
and for any real number x  0 and integers a; b > 0,

dx=ae
b

D
l x
ab
m
; (3.4)

bx=ac
b
	
D
j x
ab
k
; (3.5)
la
b
m

a C .b  1/
b
; (3.6)
ja
b
k

a  .b  1/
b
: (3.7)
The floor function f .x/ D bxc is monotonically increasing, as is the ceiling function
f .x/ D dxe.
Modular arithmetic
For any integer a and any positive integer n, the value a mod n is the remainder
(or residue) of the quotient a=n:
a mod n D a  n ba=nc : (3.8)
It follows that
0  a mod n < n : (3.9)
Given a well-defined notion of the remainder of one integer when divided by another,
it is convenient to provide special notation to indicate equality of remainders.
If .a mod n/ D .b mod n/, we write a  b .mod n/ and say that a is equivalent
to b, modulo n. In other words, a  b .mod n/ if a and b have the same remainder
when divided by n. Equivalently, a  b .mod n/ if and only if n is a divisor
of b  a. We write a 6 b .mod n/ if a is not equivalent to b, modulo n.3.2 Standard notations and common functions 55
Polynomials
Given a nonnegative integer d, a polynomial in n of degree d is a function p.n/
of the form
p.n/ D
Xd
iD0
aini ;
where the constants a0; a1; : : : ;ad are the coefficients of the polynomial and
ad § 0. A polynomial is asymptotically positive if and only if ad > 0. For an
asymptotically positive polynomial p.n/ of degree d, we have p.n/ D Ç.nd /. For
any real constant a  0, the function na is monotonically increasing, and for any
real constant a  0, the function na is monotonically decreasing. We say that a
function f .n/ is polynomially bounded if f .n/ D O.nk/ for some constant k.
Exponentials
For all real a > 0, m, and n, we have the following identities:
a0 D 1 ;
a1 D a ;
a1 D 1=a ;
.am/n D amn ;
.am/n D .an/m ;
aman D amCn :
For all n and a  1, the function an is monotonically increasing in n. When
convenient, we shall assume 00 D 1.
We can relate the rates of growth of polynomials and exponentials by the following
fact. For all real constants a and b such that a > 1,
lim
n!1
nb
an
D 0 ; (3.10)
from which we can conclude that
nb D o.an/ :
Thus, any exponential function with a base strictly greater than 1 grows faster than
any polynomial function.
Using e to denote 2:71828 : : :, the base of the natural logarithm function, we
have for all real x,
ex D 1 C x C
x2
2ä
C
x3
3ä
C   D
1X
iD0
xi
iä
; (3.11)56 Chapter 3 Growth of Functions
where ìäî denotes the factorial function defined later in this section. For all real x,
we have the inequality
ex  1 C x ; (3.12)
where equality holds only when x D 0. When jxj  1, we have the approximation
1 C x  ex  1 C x C x2 : (3.13)
When x ! 0, the approximation of ex by 1 C x is quite good:
ex D 1 C x C Ç.x2/ :
(In this equation, the asymptotic notation is used to describe the limiting behavior
as x ! 0 rather than as x!1.) We have for all x,
lim
n!1

1 C
x
n
n
D ex : (3.14)
Logarithms
We shall use the following notations:
lg n D log2 n (binary logarithm) ,
ln n D loge n (natural logarithm) ,
lgk n D .lg n/k (exponentiation) ,
lg lg n D lg.lg n/ (composition) .
An important notational convention we shall adopt is that logarithm functions will
apply only to the next term in the formula, so that lgn C k will mean .lg n/ C k
and not lg.n C k/. If we hold b > 1 constant, then for n > 0, the function logb n
is strictly increasing.
For all real a > 0, b > 0, c > 0, and n,
a D blogb a ;
logc.ab/ D logc a C logc b ;
logb an D n logb a ;
logb a D
logc a
logc b
; (3.15)
logb.1=a/ D logb a ;
logb a D
1
loga b
;
alogb c D clogb a ; (3.16)
where, in each equation above, logarithm bases are not 1.3.2 Standard notations and common functions 57
By equation (3.15), changing the base of a logarithm from one constant to another
changes the value of the logarithm by only a constant factor, and so we shall
often use the notation ìlg nî when we donít care about constant factors, such as in
O-notation. Computer scientists find 2 to be the most natural base for logarithms
because so many algorithms and data structures involve splitting a problem into
two parts.
There is a simple series expansion for ln.1 C x/ when jxj < 1:
ln.1 C x/ D x 
x2
2
C
x3
3

x4
4
C
x5
5
    :
We also have the following inequalities for x > 1:
x
1 C x
 ln.1 C x/  x ; (3.17)
where equality holds only for x D 0.
We say that a function f .n/ is polylogarithmically bounded if f .n/ D O.lgk n/
for some constant k. We can relate the growth of polynomials and polylogarithms
by substituting lg n for n and 2a for a in equation (3.10), yielding
lim
n!1
lgb n
.2a/lg n
D lim
n!1
lgb n
na
D 0 :
From this limit, we can conclude that
lgb n D o.na/
for any constant a > 0. Thus, any positive polynomial function grows faster than
any polylogarithmic function.
Factorials
The notation nä (read ìn factorialî) is defined for integers n  0 as
nä D
(
1 if n D 0 ;
n  .n  1/ä if n > 0 :
Thus, nä D 1  2  3    n.
A weak upper bound on the factorial function is nä  nn, since each of the n
terms in the factorial product is at most n. Stirlingís approximation,
nä D
p
2n
n
e
n

1 C Ç

1
n

; (3.18)58 Chapter 3 Growth of Functions
where e is the base of the natural logarithm, gives us a tighter upper bound, and a
lower bound as well. As Exercise 3.2-3 asks you to prove,
nä D o.nn/ ;
nä D !.2n/ ;
lg.nä/ D Ç.n lg n/ ; (3.19)
where Stirlingís approximation is helpful in proving equation (3.19). The following
equation also holds for all n  1:
nä D
p
2n
n
e
n
e?n (3.20)
where
1
12n C 1
< ?n <
1
12n
: (3.21)
Functional iteration
We use the notation f .i /.n/ to denote the function f .n/ iteratively applied i times
to an initial value of n. Formally, let f .n/ be a function over the reals. For nonnegative
integers i , we recursively define
f .i /.n/ D
(
n if i D 0 ;
f .f .i1/.n// if i > 0 :
For example, if f .n/ D 2n, then f .i /.n/ D 2in.
The iterated logarithm function
We use the notation lg n (read ìlog star of nî) to denote the iterated logarithm, defined
as follows. Let lg.i / n be as defined above, with f .n/ D lg n. Because the logarithm
of a nonpositive number is undefined, lg.i / n is defined only if lg.i1/n > 0.
Be sure to distinguish lg.i / n (the logarithm function applied i times in succession,
starting with argument n) from lgi n (the logarithm of n raised to the i th power).
Then we define the iterated logarithm function as
lg n D min
∞
i  0 W lg.i / n  1


:
The iterated logarithm is a very slowly growing function:
lg 2 D 1 ;
lg 4 D 2 ;
lg 16 D 3 ;
lg 65536 D 4 ;
lg.265536/ D 5 :3.2 Standard notations and common functions 59
Since the number of atoms in the observable universe is estimated to be about 1080,
which is much less than 265536, we rarely encounter an input size n such that
lgn > 5.
Fibonacci numbers
We define the Fibonacci numbers by the following recurrence:
F0 D 0 ;
F1 D 1 ; (3.22)
Fi D Fi1 C Fi2 for i  2 :
Thus, each Fibonacci number is the sum of the two previous ones, yielding the
sequence
0; 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; : : : :
Fibonacci numbers are related to the golden ratio  and to its conjugate y, which
are the two roots of the equation
x2 D x C 1 (3.23)
and are given by the following formulas (see Exercise 3.2-6):
 D
1 C
p
5
2
(3.24)
D 1:61803 : : : ;
y D
1 
p
5
2
D :61803 : : : :
Specifically, we have
Fi D
i  yi
p
5
;
which we can prove by induction (Exercise 3.2-7). Since
??
y
??
< 1, we have
??
yi
??
p
5
<
1
p
5
<
1
2
;
which implies that60 Chapter 3 Growth of Functions
Fi D

i
p
5
C
1
2
	
; (3.25)
which is to say that the i th Fibonacci number Fi is equal to i =
p
5 rounded to the
nearest integer. Thus, Fibonacci numbers grow exponentially.
Exercises
3.2-1
Show that if f .n/ and g.n/ are monotonically increasing functions, then so are
the functions f .n/ C g.n/ and f .g.n//, and if f .n/ and g.n/ are in addition
nonnegative, then f .n/  g.n/ is monotonically increasing.
3.2-2
Prove equation (3.16).
3.2-3
Prove equation (3.19). Also prove that nä D !.2n/ and nä D o.nn/.
3.2-4 ?
Is the function dlg neä polynomially bounded? Is the function dlg lg neä polynomially
bounded?
3.2-5 ?
Which is asymptotically larger: lg.lg n/ or lg.lg n/?
3.2-6
Show that the golden ratio  and its conjugate y both satisfy the equation
x2 D x C 1.
3.2-7
Prove by induction that the i th Fibonacci number satisfies the equality
Fi D
i  yi
p
5
;
where  is the golden ratio and y is its conjugate.
3.2-8
Show that k ln k D Ç.n/ implies k D Ç.n= ln n/.64 Chapter 3 Growth of Functions
Chapter notes
Knuth [209] traces the origin of the O-notation to a number-theory text by P. Bachmann
in 1892. The o-notation was invented by E. Landau in 1909 for his discussion
of the distribution of prime numbers. The  and Ç notations were advocated by
Knuth [213] to correct the popular, but technically sloppy, practice in the literature
of using O-notation for both upper and lower bounds. Many people continue to
use the O-notation where the Ç-notation is more technically precise. Further discussion
of the history and development of asymptotic notations appears in works
by Knuth [209, 213] and Brassard and Bratley [54].
Not all authors define the asymptotic notations in the same way, although the
various definitions agree in most common situations. Some of the alternative definitions
encompass functions that are not asymptotically nonnegative, as long as
their absolute values are appropriately bounded.
Equation (3.20) is due to Robbins [297]. Other properties of elementary mathematical
functions can be found in any good mathematical reference, such as
Abramowitz and Stegun [1] or Zwillinger [362], or in a calculus book, such as
Apostol [18] or Thomas et al. [334]. Knuth [209] and Graham, Knuth, and Patashnik
[152] contain a wealth of material on discrete mathematics as used in computer
science.